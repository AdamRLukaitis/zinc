// Zinc, the bare metal stack for rust.
// Copyright 2015 zinc developers <http://zinc.rs>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY IT DIRECTLY, UPDATE THE
// SVD DEFINITION IN SUPPORT/SVD/DATA AND RE-GENERATE, ADDING THE CHANGES MADE
// INTO THE RELEVANT CHANGELOG ENTRY.

//! ioregs definition based on support/svd/data/NXP/LPC11xx-v6-z0.xml

use volatile_cell::VolatileCell;
use core::ops::Drop;

ioregs! (I2C @ 0x40000000 = {  //! I2C
  0x00 => reg32 conset {  //! I2C Control Set Register. When a one is           written to a bit of this register, the corresponding bit           in the I2C control register is set. Writing a zero has no           effect on the corresponding bit in the I2C control           register.
    2 => aa,  //= Assert acknowledge flag.
    3 => si,  //= I2C interrupt flag.
    4 => sto,  //= STOP flag.
    5 => sta,  //= START flag.
    6 => i2en,  //= I2C interface enable.
  },
  0x04 => reg32 stat {  //! I2C Status Register. During I2C operation,           this register provides detailed status codes that allow           software to determine the next action           needed.
    3..7 => status: ro,  //= These bits give the actual status               information about the I 2C interface.
  },
  0x08 => reg32 dat {  //! I2C Data Register. During master or slave           transmit mode, data to be transmitted is written to this           register. During master or slave receive mode, data that           has been received may be read from this           register.
    0..7 => data,  //= This register holds data values that               have been received or are to be               transmitted.
  },
  0x0c => reg32 adr0 {  //! I2C Slave Address Register 0. Contains the           7-bit slave address for operation of the I2C interface in           slave mode, and is not used in master mode. The least           significant bit determines whether a slave responds to           the General Call address.
    0 => gc,  //= General Call enable bit.
    1..7 => address,  //= The I2C device address for slave               mode.
  },
  0x10 => reg32 sclh {  //! SCH Duty Cycle Register High Half Word.           Determines the high time of the I2C clock.
    0..15 => sclh,  //= Count for SCL HIGH time period               selection.
  },
  0x14 => reg32 scll {  //! SCL Duty Cycle Register Low Half Word.           Determines the low time of the I2C clock. I2nSCLL and           I2nSCLH together determine the clock frequency generated           by an I2C master and certain times used in slave           mode.
    0..15 => scll,  //= Count for SCL low time period               selection.
  },
  0x18 => reg32 conclr {  //! I2C Control Clear Register. When a one is           written to a bit of this register, the corresponding bit           in the I2C control register is cleared. Writing a zero           has no effect on the corresponding bit in the I2C control           register.
    2 => aac: wo,  //= Assert acknowledge Clear               bit.
    3 => sic: wo,  //= I2C interrupt Clear bit.
    5 => stac: wo,  //= START flag Clear bit.
    6 => i2enc: wo,  //= I2C interface Disable bit.
  },
  0x1c => reg32 mmctrl {  //! Monitor mode control register.
    0 => mm_ena {  //! Monitor mode enable.
      0 => MONITOR_MODE_DISABLE,  //= Monitor mode disabled.
      1 => THE_I2C_MODULE_WILL_,  //= The I2C module will enter monitor                   mode. In this mode the SDA output will be forced                   high. This will prevent the I2C module from                   outputting data of any kind (including ACK) onto                   the I 2C data bus. Depending on the state of the                   ENA_SCL bit, the output may be also forced high,                   preventing the module from having control over                   the I2C clock line.
    }
    1 => ena_scl {  //! SCL output enable.
      0 => HIGH,  //= When this bit is cleared to 0, the                   SCL output will be forced high when the module is                   in monitor mode. As described above, this will                   prevent the module from having any control over                   the I2C clock line.
      1 => NORMAL,  //= When this bit is set, the I2C module                   may exercise the same control over the clock line                   that it would in normal operation. This means                   that, acting as a slave peripheral, the I2C                   module can stretch the clock line (hold it low)                   until it has had time to respond to an I2C                   interrupt.[1]
    }
    2 => match_all {  //! Select interrupt register               match.
      0 => MATCH,  //= When this bit is cleared, an                   interrupt will only be generated when a match                   occurs to one of the (up-to) four address                   registers described above. That is, the module                   will respond as a normal slave as far as                   address-recognition is concerned.
      1 => ANYADDRESS,  //= When this bit is set to 1 and the                   I2C is in monitor mode, an interrupt will be                   generated on ANY address received. This will                   enable the part to monitor all traffic on the                   bus.
    }
  },
  0x20 => reg32 adr1 {  //! I2C Slave Address Register 1. Contains the           7-bit slave address for operation of the I2C interface in           slave mode, and is not used in master mode. The least           significant bit determines whether a slave responds to           the General Call address.
    0 => gc,  //= General Call enable bit.
    1..7 => address,  //= The I2C device address for slave               mode.
  },
  0x24 => reg32 adr2 {  //! I2C Slave Address Register 1. Contains the           7-bit slave address for operation of the I2C interface in           slave mode, and is not used in master mode. The least           significant bit determines whether a slave responds to           the General Call address.
    0 => gc,  //= General Call enable bit.
    1..7 => address,  //= The I2C device address for slave               mode.
  },
  0x28 => reg32 adr3 {  //! I2C Slave Address Register 1. Contains the           7-bit slave address for operation of the I2C interface in           slave mode, and is not used in master mode. The least           significant bit determines whether a slave responds to           the General Call address.
    0 => gc,  //= General Call enable bit.
    1..7 => address,  //= The I2C device address for slave               mode.
  },
  0x2c => reg32 data_buffer {  //! Data buffer register. The contents of the 8           MSBs of the I2DAT shift register will be transferred to           the DATA_BUFFER automatically after every nine bits (8           bits of data plus ACK or NACK) has been received on the           bus.
    0..7 => data: ro,  //= This register holds contents of the 8               MSBs of the DAT shift register.
  },
  0x30 => reg32 mask0 {  //! I2C Slave address mask register 0. This mask           register is associated with I2ADR0 to determine an           address match. The mask register has no effect when           comparing to the General Call address           (0000000).
    1..7 => mask,  //= Mask bits.
  },
  0x34 => reg32 mask1 {  //! I2C Slave address mask register 0. This mask           register is associated with I2ADR0 to determine an           address match. The mask register has no effect when           comparing to the General Call address           (0000000).
    1..7 => mask,  //= Mask bits.
  },
  0x38 => reg32 mask2 {  //! I2C Slave address mask register 0. This mask           register is associated with I2ADR0 to determine an           address match. The mask register has no effect when           comparing to the General Call address           (0000000).
    1..7 => mask,  //= Mask bits.
  },
  0x3c => reg32 mask3 {  //! I2C Slave address mask register 0. This mask           register is associated with I2ADR0 to determine an           address match. The mask register has no effect when           comparing to the General Call address           (0000000).
    1..7 => mask,  //= Mask bits.
  },
});
ioregs! (WWDT @ 0x40004000 = {  //! Product name title=UM10398 Chapter       title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT)       Modification date=9/19/2011 Major revision=6 Minor       revision=not available
  0x00 => reg32 wdmod {  //! Watchdog mode register. This register           contains the basic mode and status of the Watchdog           Timer.
    0 => wden {  //! Watchdog enable bit. This bit is Set               Only. Setting this bit to one also locks the watchdog               clock source. Once the watchdog timer is enabled, the               watchdog timer clock source cannot be changed. If the               watchdog timer is needed in Deep-sleep mode, the               watchdog clock source must be changed to the watchdog               oscillator before setting this bit to               one.
      0 => STOPPED,  //= The watchdog timer is                   stopped.
      1 => RUN,  //= The watchdog timer is                   running.
    }
    1 => wdreset {  //! Watchdog reset enable bit. This bit is               Set Only.
      0 => NORESET,  //= A watchdog timeout will not cause a                   chip reset.
      1 => RESET,  //= A watchdog timeout will cause a chip                   reset.
    }
    2 => wdtof,  //= Watchdog time-out flag. Set when the               watchdog timer times out, by a feed error, or by               events associated with WDPROTECT, cleared by               software. Causes a chip reset if WDRESET =               1.
    3 => wdint,  //= Watchdog interrupt flag. Set when the               timer reaches the value in WDWARNINT. Cleared by               software.
    4 => wdprotect {  //! Watchdog update mode. This bit is Set               Only.
      0 => ANYTIME,  //= The watchdog reload value (WDTC) can                   be changed at any time.
      1 => LOWCOUNTER,  //= The watchdog reload value (WDTC) can                   be changed only after the counter is below the                   value of WDWARNINT and WDWINDOW. Note: this mode                   is intended for use only when WDRESET                   =1.
    }
  },
  0x04 => reg32 wdtc {  //! Watchdog timer constant register. This           register determines the time-out value.
    0..23 => count,  //= Watchdog time-out               interval.
  },
  0x08 => reg32 wdfeed {  //! Watchdog feed sequence register. Writing           0xAA followed by 0x55 to this register reloads the           Watchdog timer with the value contained in           WDTC.
    0..7 => feed: wo,  //= Feed value should be 0xAA followed by               0x55.
  },
  0x0c => reg32 wdtv {  //! Watchdog timer value register. This register           reads out the current value of the Watchdog           timer.
    0..23 => count: ro,  //= Counter timer value.
  },
  0x14 => reg32 wdwarnint {  //! Watchdog Warning Interrupt compare           value.
    0..9 => warnint,  //= Watchdog warning interrupt compare               value.
  },
  0x18 => reg32 wdwindow {  //! Watchdog Window compare value.
    0..23 => window,  //= Watchdog window value.
  },
});
ioregs! (UART @ 0x40008000 = {  //! Product name title=UM10398 Chapter       title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major       revision=7 Minor revision=not available
  0x00 => reg32 rbr {  //! Receiver Buffer Register. Contains the next           received character to be read. (DLAB=0)
    0..7 => rbr: ro,  //= The UART Receiver Buffer Register               contains the oldest received byte in the UART RX               FIFO.
  },
  0x00 => reg32 thr {  //! Transmit Holding Register. The next           character to be transmitted is written here.           (DLAB=0)
    0..7 => thr: wo,  //= Writing to the UART Transmit Holding               Register causes the data to be stored in the UART               transmit FIFO. The byte will be sent when it reaches               the bottom of the FIFO and the transmitter is               available.
  },
  0x00 => reg32 dll {  //! Divisor Latch LSB. Least significant byte of           the baud rate divisor value. The full divisor is used to           generate a baud rate from the fractional rate divider.           (DLAB=1)
    0..7 => dllsb,  //= The UART Divisor Latch LSB Register,               along with the DLM register, determines the baud rate               of the UART.
  },
  0x04 => reg32 dlm {  //! Divisor Latch MSB. Most significant byte of           the baud rate divisor value. The full divisor is used to           generate a baud rate from the fractional rate divider.           (DLAB=1)
    0..7 => dlmsb,  //= The UART Divisor Latch MSB Register,               along with the DLL register, determines the baud rate               of the UART.
  },
  0x04 => reg32 ier {  //! Interrupt Enable Register. Contains           individual interrupt enable bits for the 7 potential UART           interrupts. (DLAB=0)
    0 => rbrie {  //! RBR Interrupt Enable. Enables the               Receive Data Available interrupt for UART. It also               controls the Character Receive Time-out               interrupt.
      0 => DISABLE_THE_RDA_INTE,  //= Disable the RDA                   interrupt.
      1 => ENABLE_THE_RDA_INTER,  //= Enable the RDA                   interrupt.
    }
    1 => threie {  //! THRE Interrupt Enable. Enables the THRE               interrupt for UART. The status of this interrupt can               be read from LSR[5].
      0 => DISABLE_THE_THRE_INT,  //= Disable the THRE                   interrupt.
      1 => ENABLE_THE_THRE_INTE,  //= Enable the THRE                   interrupt.
    }
    2 => rxlie {  //! RX Line Interrupt Enable. Enables the               UART RX line status interrupts. The status of this               interrupt can be read from LSR[4:1].
      0 => DISABLE_THE_RX_LINE_,  //= Disable the RX line status                   interrupts.
      1 => ENABLE_THE_RX_LINE_S,  //= Enable the RX line status                   interrupts.
    }
    8 => abeointen {  //! Enables the end of auto-baud               interrupt.
      0 => DISABLE_END_OF_AUTO_,  //= Disable end of auto-baud                   Interrupt.
      1 => ENABLE_END_OF_AUTO_B,  //= Enable end of auto-baud                   Interrupt.
    }
    9 => abtointen {  //! Enables the auto-baud time-out               interrupt.
      0 => DISABLE_AUTO_BAUD_TI,  //= Disable auto-baud time-out                   Interrupt.
      1 => ENABLE_AUTO_BAUD_TIM,  //= Enable auto-baud time-out                   Interrupt.
    }
  },
  0x08 => reg32 iir {  //! Interrupt ID Register. Identifies which           interrupt(s) are pending.
    0 => intstatus: ro {  //! Interrupt status. Note that IIR[0] is               active low. The pending interrupt can be determined               by evaluating IIR[3:1].
      0 => PENDING,  //= At least one interrupt is                   pending.
      1 => NO_INTERRUPT_IS_PEND,  //= No interrupt is                   pending.
    }
    1..3 => intid: ro {  //! Interrupt identification. IER[3:1]               identifies an interrupt corresponding to the UART Rx               FIFO. All other combinations of IER[3:1] not listed               below are reserved (100,101,111).
      3 => E_1_RECEIVE_LINE_S,  //= 1 - Receive Line Status                   (RLS).
      2 => E_2A__RECEIVE_DATA_AV,  //= 2a - Receive Data Available                   (RDA).
      6 => E_2B__CHARACTER_TIME_,  //= 2b - Character Time-out Indicator                   (CTI).
      1 => E_3_THRE_INTERRUPT,  //= 3 - THRE Interrupt.
      0 => E_4_MODEM_INTERRUP,  //= 4 - Modem interrupt.
    }
    6..7 => fifoenable: ro,  //= These bits are equivalent to               FCR[0].
    8 => abeoint: ro,  //= End of auto-baud interrupt. True if               auto-baud has finished successfully and interrupt is               enabled.
    9 => abtoint: ro,  //= Auto-baud time-out interrupt. True if               auto-baud has timed out and interrupt is               enabled.
  },
  0x08 => reg32 fcr {  //! FIFO Control Register. Controls UART FIFO           usage and modes.
    0 => fifoen: wo {  //! FIFO Enable
      0 => DISABLED,  //= UART FIFOs are disabled. Must not be                   used in the application.
      1 => ENABLED,  //= Active high enable for both UART Rx                   and TX FIFOs and FCR[7:1] access. This bit must                   be set for proper UART operation. Any transition                   on this bit will automatically clear the UART                   FIFOs.
    }
    1 => rxfifores: wo {  //! RX FIFO Reset
      0 => NO_IMPACT_ON_EITHER_,  //= No impact on either of UART                   FIFOs.
      1 => CLEAR,  //= Writing a logic 1 to FCR[1] will                   clear all bytes in UART Rx FIFO, reset the                   pointer logic. This bit is                   self-clearing.
    }
    2 => txfifores: wo {  //! TX FIFO Reset
      0 => NO_IMPACT_ON_EITHER_,  //= No impact on either of UART                   FIFOs.
      1 => CLEAR,  //= Writing a logic 1 to FCR[2] will                   clear all bytes in UART TX FIFO, reset the                   pointer logic. This bit is                   self-clearing.
    }
    6..7 => rxtl: wo {  //! RX Trigger Level. These two bits               determine how many receiver UART FIFO characters must               be written before an interrupt is               activated.
      0 => TRIGGER_LEVEL_0_1_C,  //= Trigger level 0 (1 character or                   0x01).
      1 => TRIGGER_LEVEL_1_4_C,  //= Trigger level 1 (4 characters or                   0x04).
      2 => TRIGGER_LEVEL_2_8_C,  //= Trigger level 2 (8 characters or                   0x08).
      3 => TRIGGER_LEVEL_3_14_,  //= Trigger level 3 (14 characters or                   0x0E).
    }
  },
  0x0c => reg32 lcr {  //! Line Control Register. Contains controls for           frame formatting and break generation.
    0..1 => wls {  //! Word Length Select
      0 => E_5_BIT_CHARACTER_LENG,  //= 5-bit character                   length.
      1 => E_6_BIT_CHARACTER_LENG,  //= 6-bit character                   length.
      2 => E_7_BIT_CHARACTER_LENG,  //= 7-bit character                   length.
      3 => E_8_BIT_CHARACTER_LENG,  //= 8-bit character                   length.
    }
    2 => sbs {  //! Stop Bit Select
      0 => E_1_STOP_BIT_,  //= 1 stop bit.
      1 => E_2_STOP_BITS,  //= 2 stop bits (1.5 if                   LCR[1:0]=00).
    }
    3 => pe {  //! Parity Enable
      0 => DISABLE_PARITY_GENER,  //= Disable parity generation and                   checking.
      1 => ENABLE_PARITY_GENERA,  //= Enable parity generation and                   checking.
    }
    4..5 => ps {  //! Parity Select
      0 => ODD_PARITY_NUMBER_O,  //= Odd parity. Number of 1s in the                   transmitted character and the attached parity bit                   will be odd.
      1 => EVEN_PARITY_NUMBER_,  //= Even Parity. Number of 1s in the                   transmitted character and the attached parity bit                   will be even.
      2 => FORCED_1_STICK_PARIT,  //= Forced 1 stick parity.
      3 => FORCED_0_STICK_PARIT,  //= Forced 0 stick parity.
    }
    6 => bc {  //! Break Control
      0 => DISABLE_BREAK_TRANSM,  //= Disable break                   transmission.
      1 => ENABLE_BREAK_TRANSMI,  //= Enable break transmission. Output                   pin UART TXD is forced to logic 0 when LCR[6] is                   active high.
    }
    7 => dlab {  //! Divisor Latch Access Bit
      0 => DISABLE_ACCESS_TO_DI,  //= Disable access to Divisor                   Latches.
      1 => ENABLE_ACCESS_TO_DIV,  //= Enable access to Divisor                   Latches.
    }
  },
  0x10 => reg32 mcr {  //! Modem control register
    0 => dtrc,  //= DTR Control. Source for modem output               pin, DTR. This bit reads as 0 when modem loopback               mode is active.
    1 => rtsc,  //= RTS Control. Source for modem output pin               RTS. This bit reads as 0 when modem loopback mode is               active.
    4 => lms,  //= Loopback Mode Select. The modem loopback               mode provides a mechanism to perform diagnostic               loopback testing. Serial data from the transmitter is               connected internally to serial input of the receiver.               Input pin, RXD, has no effect on loopback and output               pin, TXD is held in marking state. The four modem               inputs (CTS, DSR, RI and DCD) are disconnected               externally. Externally, the modem outputs (RTS, DTR)               are set inactive. Internally, the four modem outputs               are connected to the four modem inputs. As a result               of these connections, the upper four bits of the MSR               will be driven by the lower four bits of the MCR               rather than the four modem inputs in normal mode.               This permits modem status interrupts to be generated               in loopback mode by writing the lower four bits of               MCR.
    6 => rtsen {  //! RTS flow control
      0 => DISABLE_AUTO_RTS_FLO,  //= Disable auto-rts flow                   control.
      1 => ENABLE_AUTO_RTS_FLOW,  //= Enable auto-rts flow                   control.
    }
    7 => ctsen {  //! CTS flow control
      0 => DISABLE_AUTO_CTS_FLO,  //= Disable auto-cts flow                   control.
      1 => ENABLE_AUTO_CTS_FLOW,  //= Enable auto-cts flow                   control.
    }
  },
  0x14 => reg32 lsr {  //! Line Status Register. Contains flags for           transmit and receive status, including line           errors.
    0 => rdr: ro {  //! Receiver Data Ready. LSR[0] is set when               the RBR holds an unread character and is cleared when               the UART RBR FIFO is empty.
      0 => EMPTY_,  //= RBR is empty.
      1 => VALID,  //= RBR contains valid                   data.
    }
    1 => oe: ro {  //! Overrun Error. The overrun error               condition is set as soon as it occurs. A LSR read               clears LSR[1]. LSR[1] is set when UART RSR has a new               character assembled and the UART RBR FIFO is full. In               this case, the UART RBR FIFO will not be overwritten               and the character in the UART RSR will be               lost.
      0 => INACTIVE,  //= Overrun error status is                   inactive.
      1 => ACTIVE,  //= Overrun error status is                   active.
    }
    2 => pe: ro {  //! Parity Error. When the parity bit of a               received character is in the wrong state, a parity               error occurs. A LSR read clears LSR[2]. Time of               parity error detection is dependent on FCR[0]. Note:               A parity error is associated with the character at               the top of the UART RBR FIFO.
      0 => INACTIVE,  //= Parity error status is                   inactive.
      1 => ACTIVE,  //= Parity error status is                   active.
    }
    3 => fe: ro {  //! Framing Error. When the stop bit of a               received character is a logic 0, a framing error               occurs. A LSR read clears LSR[3]. The time of the               framing error detection is dependent on FCR0. Upon               detection of a framing error, the RX will attempt to               re-synchronize to the data and assume that the bad               stop bit is actually an early start bit. However, it               cannot be assumed that the next received byte will be               correct even if there is no Framing Error. Note: A               framing error is associated with the character at the               top of the UART RBR FIFO.
      0 => INACTIVE,  //= Framing error status is                   inactive.
      1 => ACTIVE,  //= Framing error status is                   active.
    }
    4 => bi: ro {  //! Break Interrupt. When RXD1 is held in               the spacing state (all zeros) for one full character               transmission (start, data, parity, stop), a break               interrupt occurs. Once the break condition has been               detected, the receiver goes idle until RXD1 goes to               marking state (all ones). A LSR read clears this               status bit. The time of break detection is dependent               on FCR[0]. Note: The break interrupt is associated               with the character at the top of the UART RBR               FIFO.
      0 => INACTIVE,  //= Break interrupt status is                   inactive.
      1 => ACTIVE,  //= Break interrupt status is                   active.
    }
    5 => thre: ro {  //! Transmitter Holding Register Empty. THRE               is set immediately upon detection of an empty UART               THR and is cleared on a THR write.
      0 => VALID,  //= THR contains valid                   data.
      1 => EMPTY_,  //= THR is empty.
    }
    6 => temt: ro {  //! Transmitter Empty. TEMT is set when both               THR and TSR are empty; TEMT is cleared when either               the TSR or the THR contain valid data.
      0 => VALID,  //= THR and/or the TSR contains valid                   data.
      1 => EMPTY_,  //= THR and the TSR are                   empty.
    }
    7 => rxfe: ro {  //! Error in RX FIFO. LSR[7] is set when a               character with a RX error such as framing error,               parity error or break interrupt, is loaded into the               RBR. This bit is cleared when the LSR register is               read and there are no subsequent errors in the UART               FIFO.
      0 => NOERROR,  //= RBR contains no UART RX errors or                   FCR[0]=0.
      1 => ERROR,  //= UART RBR contains at least one UART                   RX error.
    }
  },
  0x18 => reg32 msr {  //! Modem status register
    0 => dcts: ro {  //! Delta CTS. Set upon state change of               input CTS. Cleared on a MSR read.
      0 => NO_CHANGE_DETECTED_O,  //= No change detected on modem input                   CTS.
      1 => STATE_CHANGE_DETECTE,  //= State change detected on modem input                   CTS.
    }
    1 => ddsr: ro {  //! Delta DSR. Set upon state change of               input DSR. Cleared on a MSR read.
      0 => NO_CHANGE_DETECTED_O,  //= No change detected on modem input                   DSR.
      1 => STATE_CHANGE_DETECTE,  //= State change detected on modem input                   DSR.
    }
    2 => teri: ro {  //! Trailing Edge RI. Set upon low to high               transition of input RI. Cleared on a MSR               read.
      0 => NO_CHANGE_DETECTED_O,  //= No change detected on modem input,                   RI.
      1 => LOW_TO_HIGH_TRANSITI,  //= Low-to-high transition detected on                   RI.
    }
    3 => ddcd: ro {  //! Delta DCD. Set upon state change of               input DCD. Cleared on a MSR read.
      0 => NO_CHANGE_DETECTED_O,  //= No change detected on modem input                   DCD.
      1 => STATE_CHANGE_DETECTE,  //= State change detected on modem input                   DCD.
    }
    4 => cts: ro,  //= Clear To Send State. Complement of input               signal CTS. This bit is connected to MCR[1] in modem               loopback mode.
    5 => dsr: ro,  //= Data Set Ready State. Complement of               input signal DSR. This bit is connected to MCR[0] in               modem loopback mode.
    6 => ri: ro,  //= Ring Indicator State. Complement of               input RI. This bit is connected to MCR[2] in modem               loopback mode.
    7 => dcd: ro,  //= Data Carrier Detect State. Complement of               input DCD. This bit is connected to MCR[3] in modem               loopback mode.
  },
  0x1c => reg32 scr {  //! Scratch Pad Register. Eight-bit temporary           storage for software.
    0..7 => pad,  //= A readable, writable byte.
  },
  0x20 => reg32 acr {  //! Auto-baud Control Register. Contains           controls for the auto-baud feature.
    0 => start {  //! Start bit. This bit is automatically               cleared after auto-baud completion.
      0 => STOP,  //= Auto-baud stop (auto-baud is not                   running).
      1 => START,  //= Auto-baud start (auto-baud is                   running). Auto-baud run bit. This bit is                   automatically cleared after auto-baud                   completion.
    }
    1 => mode {  //! Auto-baud mode select
      0 => MODE_0_,  //= Mode 0.
      1 => MODE_1_,  //= Mode 1.
    }
    2 => autorestart {  //! Restart enable
      0 => NO_RESTART,  //= No restart
      1 => RESTART_IN_CASE_OF_T,  //= Restart in case of time-out (counter                   restarts at next UART Rx falling                   edge)
    }
    8 => abeointclr {  //! End of auto-baud interrupt clear (write               only accessible)
      0 => NOIMPACT,  //= Writing a 0 has no                   impact.
      1 => CLEAR,  //= Writing a 1 will clear the                   corresponding interrupt in the IIR.
    }
    9 => abtointclr {  //! Auto-baud time-out interrupt clear               (write only accessible)
      0 => NOIMPACT,  //= Writing a 0 has no                   impact.
      1 => CLEAR,  //= Writing a 1 will clear the                   corresponding interrupt in the IIR.
    }
  },
  0x28 => reg32 fdr {  //! Fractional Divider Register. Generates a           clock input for the baud rate divider.
    0..3 => divaddval,  //= Baud rate generation pre-scaler divisor               value. If this field is 0, fractional baud rate               generator will not impact the UART baud               rate.
    4..7 => mulval,  //= Baud rate pre-scaler multiplier value.               This field must be greater or equal 1 for UART to               operate properly, regardless of whether the               fractional baud rate generator is used or               not.
  },
  0x30 => reg32 ter {  //! Transmit Enable Register. Turns off UART           transmitter for use with software flow           control.
    7 => txen,  //= When this bit is 1, as it is after a               Reset, data written to the THR is output on the TXD               pin as soon as any preceding data has been sent. If               this bit cleared to 0 while a character is being               sent, the transmission of that character is               completed, but no further characters are sent until               this bit is set again. In other words, a 0 in this               bit blocks the transfer of characters from the THR or               TX FIFO into the transmit shift register. Software               can clear this bit when it detects that the a               hardware-handshaking TX-permit signal (CTS) has gone               false, or with software handshaking, when it receives               an XOFF character (DC3). Software can set this bit               again when it detects that the TX-permit signal has               gone true, or when it receives an XON (DC1)               character.
  },
  0x4c => reg32 rs485ctrl {  //! RS-485/EIA-485 Control. Contains controls to           configure various aspects of RS-485/EIA-485           modes.
    0 => nmmen {  //! NMM enable.
      0 => DISABLED,  //= RS-485/EIA-485 Normal Multidrop Mode                   (NMM) is disabled.
      1 => ENABLED,  //= RS-485/EIA-485 Normal Multidrop Mode                   (NMM) is enabled. In this mode, an address is                   detected when a received byte causes the UART to                   set the parity error and generate an                   interrupt.
    }
    1 => rxdis {  //! Receiver enable.
      0 => ENABLED,  //= The receiver is                   enabled.
      1 => DISABLED,  //= The receiver is                   disabled.
    }
    2 => aaden {  //! AAD enable.
      0 => DISABLED,  //= Auto Address Detect (AAD) is                   disabled.
      1 => ENABLED,  //= Auto Address Detect (AAD) is                   enabled.
    }
    3 => sel {  //! Select direction control               pin
      0 => RTS,  //= If direction control is enabled (bit                   DCTRL = 1), pin RTS is used for direction                   control.
      1 => DTR,  //= If direction control is enabled (bit                   DCTRL = 1), pin DTR is used for direction                   control.
    }
    4 => dctrl {  //! Auto direction control               enable.
      0 => DISABLE_AUTO_DIRECTI,  //= Disable Auto Direction                   Control.
      1 => ENABLE_AUTO_DIRECTIO,  //= Enable Auto Direction                   Control.
    }
    5 => oinv {  //! Polarity control. This bit reverses the               polarity of the direction control signal on the RTS               (or DTR) pin.
      0 => LOW,  //= The direction control pin will be                   driven to logic 0 when the transmitter has data                   to be sent. It will be driven to logic 1 after                   the last bit of data has been                   transmitted.
      1 => HIGH,  //= The direction control pin will be                   driven to logic 1 when the transmitter has data                   to be sent. It will be driven to logic 0 after                   the last bit of data has been                   transmitted.
    }
  },
  0x50 => reg32 rs485adrmatch {  //! RS-485/EIA-485 address match. Contains the           address match value for RS-485/EIA-485           mode.
    0..7 => adrmatch,  //= Contains the address match               value.
  },
  0x54 => reg32 rs485dly {  //! RS-485/EIA-485 direction control           delay.
    0..7 => dly,  //= Contains the direction control (RTS or               DTR) delay value. This register works in conjunction               with an 8-bit counter.
  },
});
ioregs! (CT16B0 @ 0x4000c000 = {  //! Product name title=UM10398 Chapter       title=LPC1100XL series: 16-bit counter/timer CT16B0/1       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 ir {  //! Interrupt Register (IR). The IR can be           written to clear interrupts. The IR can be read to           identify which of five possible interrupt sources are           pending.
    0 => mr0int,  //= Interrupt flag for match channel               0.
    1 => mr1int,  //= Interrupt flag for match channel               1.
    2 => mr2int,  //= Interrupt flag for match channel               2.
    3 => mr3int,  //= Interrupt flag for match channel               3.
    4 => cr0int,  //= Interrupt flag for capture channel 0               event.
    5 => cr1int,  //= Interrupt flag for capture channel 1               event.
  },
  0x04 => reg32 tcr {  //! Timer Control Register (TCR). The TCR is           used to control the Timer Counter functions. The Timer           Counter can be disabled or reset through the           TCR.
    0 => cen,  //= Counter Enable. When one, the Timer               Counter and Prescale Counter are enabled for               counting. When zero, the counters are               disabled.
    1 => crst,  //= Counter Reset. When one, the Timer               Counter and the Prescale Counter are synchronously               reset on the next positive edge of PCLK. The counters               remain reset until TCR[1] is returned to               zero.
  },
  0x08 => reg32 tc {  //! Timer Counter (TC). The 16-bit TC is           incremented every PR+1 cycles of PCLK. The TC is           controlled through the TCR.
    0..15 => tc,  //= Timer counter value.
  },
  0x0c => reg32 pr {  //! Prescale Register (PR). When the Prescale           Counter (below) is equal to this value, the next clock           increments the TC and clears the PC.
    0..15 => pr,  //= Prescale max value.
  },
  0x10 => reg32 pc {  //! Prescale Counter (PC). The 16-bit PC is a           counter which is incremented to the value stored in PR.           When the value in PR is reached, the TC is incremented           and the PC is cleared. The PC is observable and           controllable through the bus interface.
    0..15 => pc,  //= Prescale counter value.
  },
  0x14 => reg32 mcr {  //! Match Control Register (MCR). The MCR is           used to control if an interrupt is generated and if the           TC is reset when a Match occurs.
    0 => mr0i {  //! Interrupt on MR0: an interrupt is               generated when MR0 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => mr0r {  //! Reset on MR0: the TC will be reset if               MR0 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => mr0s {  //! Stop on MR0: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR0 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => mr1i {  //! Interrupt on MR1: an interrupt is               generated when MR1 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => mr1r {  //! Reset on MR1: the TC will be reset if               MR1 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => mr1s {  //! Stop on MR1: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR1 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    6 => mr2i {  //! Interrupt on MR2: an interrupt is               generated when MR2 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    7 => mr2r {  //! Reset on MR2: the TC will be reset if               MR2 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    8 => mr2s {  //! Stop on MR2: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR2 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    9 => mr3i {  //! Interrupt on MR3: an interrupt is               generated when MR3 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    10 => mr3r {  //! Reset on MR3: the TC will be reset if               MR3 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    11 => mr3s {  //! Stop on MR3: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR3 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x18 => reg32 mr0 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x1c => reg32 mr1 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x20 => reg32 mr2 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x24 => reg32 mr3 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x28 => reg32 ccr {  //! Capture Control Register (CCR). The CCR           controls which edges of the capture inputs are used to           load the Capture Registers and whether or not an           interrupt is generated when a capture takes           place.
    0 => cap0re {  //! Capture on CT16Bn_CAP0 rising edge: a               sequence of 0 then 1 on CT16Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => cap0fe {  //! Capture on CT16Bn_CAP0 falling edge: a               sequence of 1 then 0 on CT16Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => cap0i {  //! Interrupt on CT16Bn_CAP0 event: a CR0               load due to a CT16Bn_CAP0 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => cap1re {  //! Capture on CT16Bn_CAP1 rising edge: a               sequence of 0 then 1 on CT16Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => cap1fe {  //! Capture on CT16Bn_CAP1 falling edge: a               sequence of 1 then 0 on CT16Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => cap1i {  //! Interrupt on CT16Bn_CAP1 event: a CR1               load due to a CT16Bn_CAP1 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x2c => reg32 cr0 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..15 => cap: ro,  //= Timer counter capture               value.
  },
  0x30 => reg32 cr1 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..15 => cap: ro,  //= Timer counter capture               value.
  },
  0x3c => reg32 emr {  //! External Match Register (EMR). The EMR           controls the match function and the external match pins           CT16B0_MAT[2:0].
    0 => em0,  //= External Match 0. This bit reflects the               state of output CT16B0_MAT0/CT16B1_MAT0, whether or               not this output is connected to its pin. When a match               occurs between the TC and MR0, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4]               control the functionality of this output. This bit is               driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    1 => em1,  //= External Match 1. This bit reflects the               state of output CT16B0_MAT1/CT16B1_MAT1, whether or               not this output is connected to its pin. When a match               occurs between the TC and MR1, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6]               control the functionality of this output. This bit is               driven to the CT16B0_MAT1/CT16B1_MAT1 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    2 => em2,  //= External Match 2. This bit reflects the               state of output match channel 2, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR2, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[9:8] control               the functionality of this output. Note that on               counter/timer 0 this match channel is not pinned out.               This bit is driven to the CT16B1_MAT2 pin if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    3 => em3,  //= External Match 3. This bit reflects the               state of output of match channel 3. When a match               occurs between the TC and MR3, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits               EMR[11:10] control the functionality of this output.               There is no output pin available for this channel on               either of the 16-bit timers.
    4..5 => emc0 {  //! External Match Control 0. Determines the               functionality of External Match 0.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    6..7 => emc1 {  //! External Match Control 1. Determines the               functionality of External Match 1.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    8..9 => emc2 {  //! External Match Control 2. Determines the               functionality of External Match 2.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    10..11 => emc3 {  //! External Match Control 3. Determines the               functionality of External Match 3.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
  },
  0x70 => reg32 ctcr {  //! Count Control Register (CTCR). The CTCR           selects between Timer and Counter mode, and in Counter           mode selects the signal and edge(s) for           counting.
    0..1 => ctm {  //! Counter/Timer Mode. This field selects               which rising PCLK edges can increment Timer's               Prescale Counter (PC), or clear PC and increment               Timer Counter (TC).
      0 => TIMER_MODE_EVERY_RI,  //= Timer Mode: every rising PCLK                   edge
      1 => COUNTER_MODE_TC_IS_RISING,  //= Counter Mode: TC is incremented on                   rising edges on the CAP input selected by bits                   3:2.
      2 => COUNTER_MODE_TC_IS_FALLING,  //= Counter Mode: TC is incremented on                   falling edges on the CAP input selected by bits                   3:2.
      3 => COUNTER_MODE_TC_IS_BOTH,  //= Counter Mode: TC is incremented on                   both edges on the CAP input selected by bits                   3:2.
    }
    2..3 => cis {  //! Count Input Select. In counter mode               (when bits 1:0 in this register are not 00), these               bits select which CAP pin is sampled for clocking.               Note: If Counter mode is selected in the CTCR               register, bits 2:0 in the Capture Control Register               (CCR) must be programmed as 000.
      0 => CT16BN_CAP0,  //= CT16Bn_CAP0
      1 => CT16BN_CAP1,  //= CT16Bn_CAP1
    }
    4 => encc,  //= Setting this bit to one enables clearing               of the timer and the prescaler when the capture-edge               event specified in bits 7:5 occurs.
    5..7 => selcc {  //! When bit 4 is one, these bits select               which capture input edge will cause the timer and               prescaler to be cleared. These bits have no effect               when bit 4 is zero.
      0 => RISING_EDGE_OF_CAP0_,  //= Rising Edge of CAP0 clears the timer                   (if bit 4 is set).
      1 => FALLING_EDGE_OF_CAP0,  //= Falling Edge of CAP0 clears the                   timer (if bit 4 is set).
      2 => RISING_EDGE_OF_CAP1_,  //= Rising Edge of CAP1 clears the timer                   (if bit 4 is set).
      3 => FALLING_EDGE_OF_CAP1,  //= Falling Edge of CAP1 clears the                   timer (if bit 4 is set).
    }
  },
  0x74 => reg32 pwmc {  //! PWM Control Register (PWMCON). The PWMCON           enables PWM mode for the external match pins           CT16B0_MAT[2:0].
    0 => pwmen0 {  //! PWM channel0 enable
      0 => CT16BN_MAT0_IS_CONTR,  //= CT16Bn_MAT0 is controlled by                   EM0.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT16Bn_MAT0.
    }
    1 => pwmen1 {  //! PWM channel1 enable
      0 => CT16BN_MAT1_IS_CONTR,  //= CT16Bn_MAT1 is controlled by                   EM1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT16Bn_MAT1.
    }
    2 => pwmen2 {  //! PWM channel2 enable
      0 => MATCH_CHANNEL_2_OR_P,  //= Match channel 2 or pin CT16B0_MAT2                   is controlled by EM2. Match channel 2 is not                   pinned out on timer 1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for match                   channel 2 or pin CT16B0_MAT2.
    }
    3 => pwmen3 {  //! PWM channel3 enable Note: It is               recommended to use match channel 3 to set the PWM               cycle because it is not pinned out.
      0 => MATCH_CHANNEL_3_MATC,  //= Match channel 3 match channel 3 is                   controlled by EM3.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for match                   channel 3match channel 3.
    }
  },
});
ioregs! (CT16B1 @ 0x40010000 = {  //! Product name title=UM10398 Chapter       title=LPC1100XL series: 16-bit counter/timer CT16B0/1       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 ir {  //! Interrupt Register (IR). The IR can be           written to clear interrupts. The IR can be read to           identify which of five possible interrupt sources are           pending.
    0 => mr0int,  //= Interrupt flag for match channel               0.
    1 => mr1int,  //= Interrupt flag for match channel               1.
    2 => mr2int,  //= Interrupt flag for match channel               2.
    3 => mr3int,  //= Interrupt flag for match channel               3.
    4 => cr0int,  //= Interrupt flag for capture channel 0               event.
    5 => cr1int,  //= Interrupt flag for capture channel 1               event.
  },
  0x04 => reg32 tcr {  //! Timer Control Register (TCR). The TCR is           used to control the Timer Counter functions. The Timer           Counter can be disabled or reset through the           TCR.
    0 => cen,  //= Counter Enable. When one, the Timer               Counter and Prescale Counter are enabled for               counting. When zero, the counters are               disabled.
    1 => crst,  //= Counter Reset. When one, the Timer               Counter and the Prescale Counter are synchronously               reset on the next positive edge of PCLK. The counters               remain reset until TCR[1] is returned to               zero.
  },
  0x08 => reg32 tc {  //! Timer Counter (TC). The 16-bit TC is           incremented every PR+1 cycles of PCLK. The TC is           controlled through the TCR.
    0..15 => tc,  //= Timer counter value.
  },
  0x0c => reg32 pr {  //! Prescale Register (PR). When the Prescale           Counter (below) is equal to this value, the next clock           increments the TC and clears the PC.
    0..15 => pr,  //= Prescale max value.
  },
  0x10 => reg32 pc {  //! Prescale Counter (PC). The 16-bit PC is a           counter which is incremented to the value stored in PR.           When the value in PR is reached, the TC is incremented           and the PC is cleared. The PC is observable and           controllable through the bus interface.
    0..15 => pc,  //= Prescale counter value.
  },
  0x14 => reg32 mcr {  //! Match Control Register (MCR). The MCR is           used to control if an interrupt is generated and if the           TC is reset when a Match occurs.
    0 => mr0i {  //! Interrupt on MR0: an interrupt is               generated when MR0 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => mr0r {  //! Reset on MR0: the TC will be reset if               MR0 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => mr0s {  //! Stop on MR0: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR0 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => mr1i {  //! Interrupt on MR1: an interrupt is               generated when MR1 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => mr1r {  //! Reset on MR1: the TC will be reset if               MR1 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => mr1s {  //! Stop on MR1: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR1 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    6 => mr2i {  //! Interrupt on MR2: an interrupt is               generated when MR2 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    7 => mr2r {  //! Reset on MR2: the TC will be reset if               MR2 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    8 => mr2s {  //! Stop on MR2: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR2 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    9 => mr3i {  //! Interrupt on MR3: an interrupt is               generated when MR3 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    10 => mr3r {  //! Reset on MR3: the TC will be reset if               MR3 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    11 => mr3s {  //! Stop on MR3: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR3 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x18 => reg32 mr0 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x1c => reg32 mr1 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x20 => reg32 mr2 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x24 => reg32 mr3 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..15 => f_match,  //= Timer counter match value.
  },
  0x28 => reg32 ccr {  //! Capture Control Register (CCR). The CCR           controls which edges of the capture inputs are used to           load the Capture Registers and whether or not an           interrupt is generated when a capture takes           place.
    0 => cap0re {  //! Capture on CT16Bn_CAP0 rising edge: a               sequence of 0 then 1 on CT16Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => cap0fe {  //! Capture on CT16Bn_CAP0 falling edge: a               sequence of 1 then 0 on CT16Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => cap0i {  //! Interrupt on CT16Bn_CAP0 event: a CR0               load due to a CT16Bn_CAP0 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => cap1re {  //! Capture on CT16Bn_CAP1 rising edge: a               sequence of 0 then 1 on CT16Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => cap1fe {  //! Capture on CT16Bn_CAP1 falling edge: a               sequence of 1 then 0 on CT16Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => cap1i {  //! Interrupt on CT16Bn_CAP1 event: a CR1               load due to a CT16Bn_CAP1 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x2c => reg32 cr0 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..15 => cap: ro,  //= Timer counter capture               value.
  },
  0x30 => reg32 cr1 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..15 => cap: ro,  //= Timer counter capture               value.
  },
  0x3c => reg32 emr {  //! External Match Register (EMR). The EMR           controls the match function and the external match pins           CT16B0_MAT[2:0].
    0 => em0,  //= External Match 0. This bit reflects the               state of output CT16B0_MAT0/CT16B1_MAT0, whether or               not this output is connected to its pin. When a match               occurs between the TC and MR0, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4]               control the functionality of this output. This bit is               driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    1 => em1,  //= External Match 1. This bit reflects the               state of output CT16B0_MAT1/CT16B1_MAT1, whether or               not this output is connected to its pin. When a match               occurs between the TC and MR1, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6]               control the functionality of this output. This bit is               driven to the CT16B0_MAT1/CT16B1_MAT1 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    2 => em2,  //= External Match 2. This bit reflects the               state of output match channel 2, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR2, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[9:8] control               the functionality of this output. Note that on               counter/timer 0 this match channel is not pinned out.               This bit is driven to the CT16B1_MAT2 pin if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    3 => em3,  //= External Match 3. This bit reflects the               state of output of match channel 3. When a match               occurs between the TC and MR3, this bit can either               toggle, go LOW, go HIGH, or do nothing. Bits               EMR[11:10] control the functionality of this output.               There is no output pin available for this channel on               either of the 16-bit timers.
    4..5 => emc0 {  //! External Match Control 0. Determines the               functionality of External Match 0.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    6..7 => emc1 {  //! External Match Control 1. Determines the               functionality of External Match 1.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    8..9 => emc2 {  //! External Match Control 2. Determines the               functionality of External Match 2.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    10..11 => emc3 {  //! External Match Control 3. Determines the               functionality of External Match 3.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT16Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT16Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
  },
  0x70 => reg32 ctcr {  //! Count Control Register (CTCR). The CTCR           selects between Timer and Counter mode, and in Counter           mode selects the signal and edge(s) for           counting.
    0..1 => ctm {  //! Counter/Timer Mode. This field selects               which rising PCLK edges can increment Timer's               Prescale Counter (PC), or clear PC and increment               Timer Counter (TC).
      0 => TIMER_MODE_EVERY_RI,  //= Timer Mode: every rising PCLK                   edge
      1 => COUNTER_MODE_TC_IS_RISING,  //= Counter Mode: TC is incremented on                   rising edges on the CAP input selected by bits                   3:2.
      2 => COUNTER_MODE_TC_IS_FALLING,  //= Counter Mode: TC is incremented on                   falling edges on the CAP input selected by bits                   3:2.
      3 => COUNTER_MODE_TC_IS_BOTH,  //= Counter Mode: TC is incremented on                   both edges on the CAP input selected by bits                   3:2.
    }
    2..3 => cis {  //! Count Input Select. In counter mode               (when bits 1:0 in this register are not 00), these               bits select which CAP pin is sampled for clocking.               Note: If Counter mode is selected in the CTCR               register, bits 2:0 in the Capture Control Register               (CCR) must be programmed as 000.
      0 => CT16BN_CAP0,  //= CT16Bn_CAP0
      1 => CT16BN_CAP1,  //= CT16Bn_CAP1
    }
    4 => encc,  //= Setting this bit to one enables clearing               of the timer and the prescaler when the capture-edge               event specified in bits 7:5 occurs.
    5..7 => selcc {  //! When bit 4 is one, these bits select               which capture input edge will cause the timer and               prescaler to be cleared. These bits have no effect               when bit 4 is zero.
      0 => RISING_EDGE_OF_CAP0_,  //= Rising Edge of CAP0 clears the timer                   (if bit 4 is set).
      1 => FALLING_EDGE_OF_CAP0,  //= Falling Edge of CAP0 clears the                   timer (if bit 4 is set).
      2 => RISING_EDGE_OF_CAP1_,  //= Rising Edge of CAP1 clears the timer                   (if bit 4 is set).
      3 => FALLING_EDGE_OF_CAP1,  //= Falling Edge of CAP1 clears the                   timer (if bit 4 is set).
    }
  },
  0x74 => reg32 pwmc {  //! PWM Control Register (PWMCON). The PWMCON           enables PWM mode for the external match pins           CT16B0_MAT[2:0].
    0 => pwmen0 {  //! PWM channel0 enable
      0 => CT16BN_MAT0_IS_CONTR,  //= CT16Bn_MAT0 is controlled by                   EM0.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT16Bn_MAT0.
    }
    1 => pwmen1 {  //! PWM channel1 enable
      0 => CT16BN_MAT1_IS_CONTR,  //= CT16Bn_MAT1 is controlled by                   EM1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT16Bn_MAT1.
    }
    2 => pwmen2 {  //! PWM channel2 enable
      0 => MATCH_CHANNEL_2_OR_P,  //= Match channel 2 or pin CT16B0_MAT2                   is controlled by EM2. Match channel 2 is not                   pinned out on timer 1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for match                   channel 2 or pin CT16B0_MAT2.
    }
    3 => pwmen3 {  //! PWM channel3 enable Note: It is               recommended to use match channel 3 to set the PWM               cycle because it is not pinned out.
      0 => MATCH_CHANNEL_3_MATC,  //= Match channel 3 match channel 3 is                   controlled by EM3.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for match                   channel 3match channel 3.
    }
  },
});
ioregs! (CT32B0 @ 0x40014000 = {  //! Product name title=UM10398 Chapter       title=LPC1100XL series: 32-bit counter/timer CT32B0/1       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 ir {  //! Interrupt Register (IR). The IR can be           written to clear interrupts. The IR can be read to           identify which of five possible interrupt sources are           pending.
    0 => mr0int,  //= Interrupt flag for match channel               0.
    1 => mr1int,  //= Interrupt flag for match channel               1.
    2 => mr2int,  //= Interrupt flag for match channel               2.
    3 => mr3int,  //= Interrupt flag for match channel               3.
    4 => cr0int,  //= Interrupt flag for capture channel 0               event.
    5 => cr1int,  //= Interrupt flag for capture channel 1               event.
  },
  0x04 => reg32 tcr {  //! Timer Control Register (TCR). The TCR is           used to control the Timer Counter functions. The Timer           Counter can be disabled or reset through the           TCR.
    0 => cen,  //= When one, the Timer Counter and Prescale               Counter are enabled for counting. When zero, the               counters are disabled.
    1 => crst,  //= When one, the Timer Counter and the               Prescale Counter are synchronously reset on the next               positive edge of PCLK. The counters remain reset               until TCR[1] is returned to zero.
  },
  0x08 => reg32 tc {  //! Timer Counter (TC). The 32-bit TC is           incremented every PR+1 cycles of PCLK. The TC is           controlled through the TCR.
    0..31 => tc,  //= Timer counter value.
  },
  0x0c => reg32 pr {  //! Prescale Register (PR). When the Prescale           Counter (below) is equal to this value, the next clock           increments the TC and clears the PC.
    0..31 => pr,  //= Prescale value.
  },
  0x10 => reg32 pc {  //! Prescale Counter (PC). The 32-bit PC is a           counter which is incremented to the value stored in PR.           When the value in PR is reached, the TC is incremented           and the PC is cleared. The PC is observable and           controllable through the bus interface.
    0..31 => pc,  //= Prescale counter value.
  },
  0x14 => reg32 mcr {  //! Match Control Register (MCR). The MCR is           used to control if an interrupt is generated and if the           TC is reset when a Match occurs.
    0 => mr0i {  //! Interrupt on MR0: an interrupt is               generated when MR0 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => mr0r {  //! Reset on MR0: the TC will be reset if               MR0 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => mr0s {  //! Stop on MR0: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR0 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => mr1i {  //! Interrupt on MR1: an interrupt is               generated when MR1 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => mr1r {  //! Reset on MR1: the TC will be reset if               MR1 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => mr1s {  //! Stop on MR1: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR1 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    6 => mr2i {  //! Interrupt on MR2: an interrupt is               generated when MR2 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    7 => mr2r {  //! Reset on MR2: the TC will be reset if               MR2 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    8 => mr2s {  //! Stop on MR2: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR2 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    9 => mr3i {  //! Interrupt on MR3: an interrupt is               generated when MR3 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    10 => mr3r {  //! Reset on MR3: the TC will be reset if               MR3 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    11 => mr3s {  //! Stop on MR3: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR3 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x18 => reg32 mr0 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x1c => reg32 mr1 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x20 => reg32 mr2 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x24 => reg32 mr3 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x28 => reg32 ccr {  //! Capture Control Register (CCR). The CCR           controls which edges of the capture inputs are used to           load the Capture Registers and whether or not an           interrupt is generated when a capture takes           place.
    0 => cap0re {  //! Capture on CT32Bn_CAP0 rising edge: a               sequence of 0 then 1 on CT32Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => cap0fe {  //! Capture on CT32Bn_CAP0 falling edge: a               sequence of 1 then 0 on CT32Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => cap0i {  //! Interrupt on CT32Bn_CAP0 event: a CR0               load due to a CT32Bn_CAP0 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => cap1re {  //! Capture on CT32Bn_CAP1 rising edge: a               sequence of 0 then 1 on CT32Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => cap1fe {  //! Capture on CT32Bn_CAP1 falling edge: a               sequence of 1 then 0 on CT32Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => cap1i {  //! Interrupt on CT32Bn_CAP1 event: a CR1               load due to a CT32Bn_CAP1 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x2c => reg32 cr0 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..31 => cap: ro,  //= Timer counter capture               value.
  },
  0x30 => reg32 cr1 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..31 => cap: ro,  //= Timer counter capture               value.
  },
  0x3c => reg32 emr {  //! External Match Register (EMR). The EMR           controls the match function and the external match pins           CT32B0_MAT[3:0].
    0 => em0,  //= External Match 0. This bit reflects the               state of output CT32Bn_MAT0, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR0, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[5:4] control               the functionality of this output. This bit is driven               to the CT32B0_MAT0/CT16B1_MAT0 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    1 => em1,  //= External Match 1. This bit reflects the               state of output CT32Bn_MAT1, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR1, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[7:6] control               the functionality of this output. This bit is driven               to the CT32B0_MAT1/CT16B1_MAT1 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    2 => em2,  //= External Match 2. This bit reflects the               state of output CT32Bn_MAT2, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR2, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[9:8] control               the functionality of this output. This bit is driven               to the CT32B0_MAT2/CT16B1_MAT2 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    3 => em3,  //= External Match 3. This bit reflects the               state of output CT32Bn_MAT3, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR3, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[11:10]               control the functionality of this output. This bit is               driven to the CT32B0_MAT3/CT16B1_MAT3 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    4..5 => emc0 {  //! External Match Control 0. Determines the               functionality of External Match 0.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    6..7 => emc1 {  //! External Match Control 1. Determines the               functionality of External Match 1.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    8..9 => emc2 {  //! External Match Control 2. Determines the               functionality of External Match 2.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    10..11 => emc3 {  //! External Match Control 3. Determines the               functionality of External Match 3.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
  },
  0x70 => reg32 ctcr {  //! Count Control Register (CTCR). The CTCR           selects between Timer and Counter mode, and in Counter           mode selects the signal and edge(s) for           counting.
    0..1 => ctm {  //! Counter/Timer Mode. This field selects               which rising PCLK edges can increment Timer's               Prescale Counter (PC), or clear PC and increment               Timer Counter (TC). Timer Mode: every rising PCLK               edge
      0 => TIMER_MODE_EVERY_RI,  //= Timer Mode: every rising PCLK                   edge
      1 => COUNTER_MODE_TC_IS_RISING,  //= Counter Mode: TC is incremented on                   rising edges on the CAP input selected by bits                   3:2.
      2 => COUNTER_MODE_TC_IS_FALLING,  //= Counter Mode: TC is incremented on                   falling edges on the CAP input selected by bits                   3:2.
      3 => COUNTER_MODE_TC_IS_BOTH,  //= Counter Mode: TC is incremented on                   both edges on the CAP input selected by bits                   3:2.
    }
    2..3 => cis {  //! Count Input Select. When bits 1:0 in               this register are not 00, these bits select which CAP               pin is sampled for clocking:
      0 => CT32BN_CAP0,  //= CT32Bn_CAP0
      1 => CT32BN_CAP1,  //= CT32Bn_CAP1
    }
    4 => encc,  //= Setting this bit to one enables clearing               of the timer and the prescaler when the capture-edge               event specified in bits 7:5 occurs.
    5..7 => selcc {  //! When bit 4 is one, these bits select               which capture input edge will cause the timer and               prescaler to be cleared. These bits have no effect               when bit 4 is zero.
      0 => RISING_EDGE_OF_CAP0_,  //= Rising Edge of CAP0 clears the timer                   (if bit 4 is set).
      1 => FALLING_EDGE_OF_CAP0,  //= Falling Edge of CAP0 clears the                   timer (if bit 4 is set).
      2 => RISING_EDGE_OF_CAP1_,  //= Rising Edge of CAP1 clears the timer                   (if bit 4 is set).
      3 => FALLING_EDGE_OF_CAP1,  //= Falling Edge of CAP1 clears the                   timer (if bit 4 is set).
    }
  },
  0x74 => reg32 pwmc {  //! PWM Control Register (PWMCON). The PWMCON           enables PWM mode for the external match pins           CT32B0_MAT[3:0].
    0 => pwmen0 {  //! PWM channel 0 enable
      0 => CT32BN_MAT0_IS_CONTR,  //= CT32Bn_MAT0 is controlled by                   EM0.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT0.
    }
    1 => pwmen1 {  //! PWM channel 1 enable
      0 => CT32BN_MAT1_IS_CONTR,  //= CT32Bn_MAT1 is controlled by                   EM1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT1.
    }
    2 => pwmen2 {  //! PWM channel 2 enable
      0 => CT32BN_MAT2_IS_CONTR,  //= CT32Bn_MAT2 is controlled by                   EM2.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT2.
    }
    3 => pwmen3 {  //! PWM channel 3 enable Note: It is               recommended to use match channel 3 to set the PWM               cycle.
      0 => CT32BN_MAT3_IS_CONTR,  //= CT32Bn_MAT3 is controlled by                   EM3.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT3.
    }
  },
});
ioregs! (CT32B1 @ 0x40018000 = {  //! Product name title=UM10398 Chapter       title=LPC1100XL series: 32-bit counter/timer CT32B0/1       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 ir {  //! Interrupt Register (IR). The IR can be           written to clear interrupts. The IR can be read to           identify which of five possible interrupt sources are           pending.
    0 => mr0int,  //= Interrupt flag for match channel               0.
    1 => mr1int,  //= Interrupt flag for match channel               1.
    2 => mr2int,  //= Interrupt flag for match channel               2.
    3 => mr3int,  //= Interrupt flag for match channel               3.
    4 => cr0int,  //= Interrupt flag for capture channel 0               event.
    5 => cr1int,  //= Interrupt flag for capture channel 1               event.
  },
  0x04 => reg32 tcr {  //! Timer Control Register (TCR). The TCR is           used to control the Timer Counter functions. The Timer           Counter can be disabled or reset through the           TCR.
    0 => cen,  //= When one, the Timer Counter and Prescale               Counter are enabled for counting. When zero, the               counters are disabled.
    1 => crst,  //= When one, the Timer Counter and the               Prescale Counter are synchronously reset on the next               positive edge of PCLK. The counters remain reset               until TCR[1] is returned to zero.
  },
  0x08 => reg32 tc {  //! Timer Counter (TC). The 32-bit TC is           incremented every PR+1 cycles of PCLK. The TC is           controlled through the TCR.
    0..31 => tc,  //= Timer counter value.
  },
  0x0c => reg32 pr {  //! Prescale Register (PR). When the Prescale           Counter (below) is equal to this value, the next clock           increments the TC and clears the PC.
    0..31 => pr,  //= Prescale value.
  },
  0x10 => reg32 pc {  //! Prescale Counter (PC). The 32-bit PC is a           counter which is incremented to the value stored in PR.           When the value in PR is reached, the TC is incremented           and the PC is cleared. The PC is observable and           controllable through the bus interface.
    0..31 => pc,  //= Prescale counter value.
  },
  0x14 => reg32 mcr {  //! Match Control Register (MCR). The MCR is           used to control if an interrupt is generated and if the           TC is reset when a Match occurs.
    0 => mr0i {  //! Interrupt on MR0: an interrupt is               generated when MR0 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => mr0r {  //! Reset on MR0: the TC will be reset if               MR0 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => mr0s {  //! Stop on MR0: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR0 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => mr1i {  //! Interrupt on MR1: an interrupt is               generated when MR1 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => mr1r {  //! Reset on MR1: the TC will be reset if               MR1 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => mr1s {  //! Stop on MR1: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR1 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    6 => mr2i {  //! Interrupt on MR2: an interrupt is               generated when MR2 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    7 => mr2r {  //! Reset on MR2: the TC will be reset if               MR2 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    8 => mr2s {  //! Stop on MR2: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR2 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    9 => mr3i {  //! Interrupt on MR3: an interrupt is               generated when MR3 matches the value in the               TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    10 => mr3r {  //! Reset on MR3: the TC will be reset if               MR3 matches it.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    11 => mr3s {  //! Stop on MR3: the TC and PC will be               stopped and TCR[0] will be set to 0 if MR3 matches               the TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x18 => reg32 mr0 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x1c => reg32 mr1 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x20 => reg32 mr2 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x24 => reg32 mr3 {  //! Match Register. MR can be enabled through           the MCR to reset the TC, stop both the TC and PC, and/or           generate an interrupt every time MR matches the           TC.
    0..31 => f_match,  //= Timer counter match value.
  },
  0x28 => reg32 ccr {  //! Capture Control Register (CCR). The CCR           controls which edges of the capture inputs are used to           load the Capture Registers and whether or not an           interrupt is generated when a capture takes           place.
    0 => cap0re {  //! Capture on CT32Bn_CAP0 rising edge: a               sequence of 0 then 1 on CT32Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    1 => cap0fe {  //! Capture on CT32Bn_CAP0 falling edge: a               sequence of 1 then 0 on CT32Bn_CAP0 will cause CR0 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    2 => cap0i {  //! Interrupt on CT32Bn_CAP0 event: a CR0               load due to a CT32Bn_CAP0 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    3 => cap1re {  //! Capture on CT32Bn_CAP1 rising edge: a               sequence of 0 then 1 on CT32Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    4 => cap1fe {  //! Capture on CT32Bn_CAP1 falling edge: a               sequence of 1 then 0 on CT32Bn_CAP1 will cause CR1 to               be loaded with the contents of TC.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
    5 => cap1i {  //! Interrupt on CT32Bn_CAP1 event: a CR1               load due to a CT32Bn_CAP1 event will generate an               interrupt.
      1 => ENABLED,  //= Enabled
      0 => DISABLED,  //= Disabled
    }
  },
  0x2c => reg32 cr0 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..31 => cap: ro,  //= Timer counter capture               value.
  },
  0x30 => reg32 cr1 {  //! Capture Register (CR). CR is loaded with the           value of TC when there is an event on the CT16Bn_CAPm           input.
    0..31 => cap: ro,  //= Timer counter capture               value.
  },
  0x3c => reg32 emr {  //! External Match Register (EMR). The EMR           controls the match function and the external match pins           CT32B0_MAT[3:0].
    0 => em0,  //= External Match 0. This bit reflects the               state of output CT32Bn_MAT0, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR0, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[5:4] control               the functionality of this output. This bit is driven               to the CT32B0_MAT0/CT16B1_MAT0 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    1 => em1,  //= External Match 1. This bit reflects the               state of output CT32Bn_MAT1, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR1, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[7:6] control               the functionality of this output. This bit is driven               to the CT32B0_MAT1/CT16B1_MAT1 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    2 => em2,  //= External Match 2. This bit reflects the               state of output CT32Bn_MAT2, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR2, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[9:8] control               the functionality of this output. This bit is driven               to the CT32B0_MAT2/CT16B1_MAT2 pins if the match               function is selected in the IOCON registers (0 = LOW,               1 = HIGH).
    3 => em3,  //= External Match 3. This bit reflects the               state of output CT32Bn_MAT3, whether or not this               output is connected to its pin. When a match occurs               between the TC and MR3, this bit can either toggle,               go LOW, go HIGH, or do nothing. Bits EMR[11:10]               control the functionality of this output. This bit is               driven to the CT32B0_MAT3/CT16B1_MAT3 pins if the               match function is selected in the IOCON registers (0               = LOW, 1 = HIGH).
    4..5 => emc0 {  //! External Match Control 0. Determines the               functionality of External Match 0.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    6..7 => emc1 {  //! External Match Control 1. Determines the               functionality of External Match 1.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    8..9 => emc2 {  //! External Match Control 2. Determines the               functionality of External Match 2.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
    10..11 => emc3 {  //! External Match Control 3. Determines the               functionality of External Match 3.
      0 => DO_NOTHING_,  //= Do Nothing.
      1 => CLEAR_THE_CORRESPOND,  //= Clear the corresponding External                   Match bit/output to 0 (CT32Bn_MATm pin is LOW if                   pinned out).
      2 => SET_THE_CORRESPONDIN,  //= Set the corresponding External Match                   bit/output to 1 (CT32Bn_MATm pin is HIGH if                   pinned out).
      3 => TOGGLE_THE_CORRESPON,  //= Toggle the corresponding External                   Match bit/output.
    }
  },
  0x70 => reg32 ctcr {  //! Count Control Register (CTCR). The CTCR           selects between Timer and Counter mode, and in Counter           mode selects the signal and edge(s) for           counting.
    0..1 => ctm {  //! Counter/Timer Mode. This field selects               which rising PCLK edges can increment Timer's               Prescale Counter (PC), or clear PC and increment               Timer Counter (TC). Timer Mode: every rising PCLK               edge
      0 => TIMER_MODE_EVERY_RI,  //= Timer Mode: every rising PCLK                   edge
      1 => COUNTER_MODE_TC_IS_RISING,  //= Counter Mode: TC is incremented on                   rising edges on the CAP input selected by bits                   3:2.
      2 => COUNTER_MODE_TC_IS_FALLING,  //= Counter Mode: TC is incremented on                   falling edges on the CAP input selected by bits                   3:2.
      3 => COUNTER_MODE_TC_IS_BOTH,  //= Counter Mode: TC is incremented on                   both edges on the CAP input selected by bits                   3:2.
    }
    2..3 => cis {  //! Count Input Select. When bits 1:0 in               this register are not 00, these bits select which CAP               pin is sampled for clocking:
      0 => CT32BN_CAP0,  //= CT32Bn_CAP0
      1 => CT32BN_CAP1,  //= CT32Bn_CAP1
    }
    4 => encc,  //= Setting this bit to one enables clearing               of the timer and the prescaler when the capture-edge               event specified in bits 7:5 occurs.
    5..7 => selcc {  //! When bit 4 is one, these bits select               which capture input edge will cause the timer and               prescaler to be cleared. These bits have no effect               when bit 4 is zero.
      0 => RISING_EDGE_OF_CAP0_,  //= Rising Edge of CAP0 clears the timer                   (if bit 4 is set).
      1 => FALLING_EDGE_OF_CAP0,  //= Falling Edge of CAP0 clears the                   timer (if bit 4 is set).
      2 => RISING_EDGE_OF_CAP1_,  //= Rising Edge of CAP1 clears the timer                   (if bit 4 is set).
      3 => FALLING_EDGE_OF_CAP1,  //= Falling Edge of CAP1 clears the                   timer (if bit 4 is set).
    }
  },
  0x74 => reg32 pwmc {  //! PWM Control Register (PWMCON). The PWMCON           enables PWM mode for the external match pins           CT32B0_MAT[3:0].
    0 => pwmen0 {  //! PWM channel 0 enable
      0 => CT32BN_MAT0_IS_CONTR,  //= CT32Bn_MAT0 is controlled by                   EM0.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT0.
    }
    1 => pwmen1 {  //! PWM channel 1 enable
      0 => CT32BN_MAT1_IS_CONTR,  //= CT32Bn_MAT1 is controlled by                   EM1.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT1.
    }
    2 => pwmen2 {  //! PWM channel 2 enable
      0 => CT32BN_MAT2_IS_CONTR,  //= CT32Bn_MAT2 is controlled by                   EM2.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT2.
    }
    3 => pwmen3 {  //! PWM channel 3 enable Note: It is               recommended to use match channel 3 to set the PWM               cycle.
      0 => CT32BN_MAT3_IS_CONTR,  //= CT32Bn_MAT3 is controlled by                   EM3.
      1 => PWM_MODE_IS_ENABLED_,  //= PWM mode is enabled for                   CT32Bn_MAT3.
    }
  },
});
ioregs! (ADC @ 0x4001c000 = {  //! 10-bit ADC
  0x00 => reg32 cr {  //! A/D Control Register. The ADCR register must           be written to select the operating mode before A/D           conversion can occur.
    0..7 => sel,  //= Selects which of the AD7:0 pins is (are)               to be sampled and converted. Bit 0 selects Pin AD0,               bit 1 selects pin AD1,..., and bit 7 selects pin AD7.               In software-controlled mode (BURST = 0), only one               channel can be selected, i.e. only one of these bits               should be 1. In hardware scan mode (BURST = 1), any               numbers of channels can be selected, i.e any or all               bits can be set to 1. If all bits are set to 0,               channel 0 is selected automatically (SEL =               0x01).
    8..15 => clkdiv,  //= The APB clock (PCLK) is divided by               CLKDIV +1 to produce the clock for the ADC, which               should be less than or equal to 4.5 MHz. Typically,               software should program the smallest value in this               field that yields a clock of 4.5 MHz or slightly               less, but in certain cases (such as a high-impedance               analog source) a slower clock may be               desirable.
    16 => burst {  //! Burst mode
      0 => SWMODE,  //= Software-controlled mode:                   Conversions are software-controlled and require                   11 clocks.
      1 => HWMODE,  //= Hardware scan mode: The AD converter                   does repeated conversions at the rate selected by                   the CLKS field, scanning (if necessary) through                   the pins selected by 1s in the SEL field. The                   first conversion after the start corresponds to                   the least-significant bit set to 1 in the SEL                   field, then the next higher bits (pins) set to 1                   are scanned if applicable. Repeated conversions                   can be terminated by clearing this bit, but the                   conversion in progress when this bit is cleared                   will be completed. Important: START bits must be                   000 when BURST = 1 or conversions will not                   start.
    }
    17..19 => clks {  //! This field selects the number of clocks               used for each conversion in Burst mode, and the               number of bits of accuracy of the result in the LS               bits of ADDR, between 11 clocks (10 bits) and 4               clocks (3 bits).
      0 => E_10BIT,  //= 11 clocks / 10 bits
      1 => E_9BIT,  //= 10 clocks / 9 bits
      2 => E_8BIT,  //= 9 clocks / 8 bits
      3 => E_7BIT,  //= 8 clocks / 7 bits
      4 => E_6BIT,  //= 7 clocks / 6 bits
      5 => E_5BIT,  //= 6 clocks / 5 bits
      6 => E_4BIT,  //= 5 clocks / 4 bits
      7 => E_3BIT,  //= 4 clocks / 3 bits
    }
    24..26 => start {  //! When the BURST bit is 0, these bits               control whether and when an A/D conversion is               started:
      0 => STOP,  //= No start (this value should be used                   when clearing PDN to 0).
      1 => START,  //= Start conversion now.
      2 => EDGEPIO0_2,  //= Start conversion when the edge                   selected by bit 27 occurs on                   PIO0_2/SSEL/CT16B0_CAP0.
      3 => EDGEPIO1_5,  //= Start conversion when the edge                   selected by bit 27 occurs on                   PIO1_5/DIR/CT32B0_CAP0.
      4 => EDGECT32B0_MAT0_1,  //= Start conversion when the edge                   selected by bit 27 occurs on                   CT32B0_MAT0[1].
      5 => EDGECT32B0_MAT1_1,  //= Start conversion when the edge                   selected by bit 27 occurs on                   CT32B0_MAT1[1].
      6 => EDGECT16B0_MAT0_1,  //= Start conversion when the edge                   selected by bit 27 occurs on                   CT16B0_MAT0[1].
      7 => EDGECT16B0_MAT1_1,  //= Start conversion when the edge                   selected by bit 27 occurs on                   CT16B0_MAT1[1].
    }
    27 => edge {  //! This bit is significant only when the               START field contains 010-111. In these cases: Start               conversion on a falling edge on the selected CAP/MAT               signal.
      0 => RISING,  //= Start conversion on a rising edge on                   the selected CAP/MAT signal.
      1 => FALLING,  //= Start conversion on a rising edge on                   the selected CAP/MAT signal.
    }
  },
  0x04 => reg32 gdr {  //! A/D Global Data Register. Contains the           result of the most recent A/D conversion.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin selected by the SEL field, divided by the voltage               on the VDD pin. Zero in the field indicates that the               voltage on the ADn pin was less than, equal to, or               close to that on VSS, while 0x3FF indicates that the               voltage on ADn was close to, equal to, or greater               than that on VREF.
    24..26 => chn,  //= These bits contain the channel from               which the result bits V_VREF were               converted.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read and when the ADCR is written. If the               ADCR is written while a conversion is still in               progress, this bit is set and a new conversion is               started.
  },
  0x30 => reg32 stat {  //! A/D Status Register. This register contains           DONE and OVERRUN flags for all of the A/D channels, as           well as the A/D interrupt flag.
    0..7 => done: ro,  //= These bits mirror the DONE status flags               that appear in the result register for each A/D               channel n.
    8..15 => overrun: ro,  //= These bits mirror the OVERRRUN status               flags that appear in the result register for each A/D               channel n. Reading ADSTAT allows checking the status               of all A/D channels simultaneously.
    16 => adint: ro,  //= This bit is the A/D interrupt flag. It               is one when any of the individual A/D channel Done               flags is asserted and enabled to contribute to the               A/D interrupt via the ADINTEN register.
  },
  0x0c => reg32 inten {  //! A/D Interrupt Enable Register. This register           contains enable bits that allow the DONE flag of each A/D           channel to be included or excluded from contributing to           the generation of an A/D interrupt.
    0..7 => adintenn,  //= These bits allow control over which A/D               channels generate interrupts for conversion               completion. When bit 0 is one, completion of a               conversion on A/D channel 0 will generate an               interrupt, when bit 1 is one, completion of a               conversion on A/D channel 1 will generate an               interrupt, etc.
    8 => adginten,  //= When 1, enables the global DONE flag in               ADDR to generate an interrupt. When 0, only the               individual A/D channels enabled by ADINTEN 7:0 will               generate interrupts.
  },
  0x10 => reg32 dr0 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x14 => reg32 dr1 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x18 => reg32 dr2 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x1c => reg32 dr3 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x20 => reg32 dr4 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x24 => reg32 dr5 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x28 => reg32 dr6 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
  0x2c => reg32 dr7 {  //! A/D Channel n Data Register. This register           contains the result of the most recent conversion           completed on channel n.
    6..15 => v_vref,  //= When DONE is 1, this field contains a               binary fraction representing the voltage on the ADn               pin, divided by the voltage on the VREF pin. Zero in               the field indicates that the voltage on the ADn pin               was less than, equal to, or close to that on VREF,               while 0x3FF indicates that the voltage on AD input               was close to, equal to, or greater than that on               VREF.
    30 => overrun,  //= This bit is 1 in burst mode if the               results of one or more conversions was (were) lost               and overwritten before the conversion that produced               the result in the V_VREF bits.This bit is cleared by               reading this register.
    31 => done,  //= This bit is set to 1 when an A/D               conversion completes. It is cleared when this               register is read.
  },
});
ioregs! (PMU @ 0x40038000 = {  //! power management unit
  0x00 => reg32 pcon {  //! Power control register
    1 => dpden {  //! Deep power-down mode               enable
      0 => SLEEPMODE,  //= ARM WFI will enter Sleep or                   Deep-sleep mode (clock to ARM Cortex-M0 core                   turned off).
      1 => DEEPPOWERDOWN,  //= ARM WFI will enter Deep-power down                   mode (ARM Cortex-M0 core                   powered-down).
    }
    8 => sleepflag {  //! Sleep mode flag
      0 => NOPOWERDOWN,  //= Read: No power-down mode entered.                   LPC111x/LPC11C1x is in Active mode. Write: No                   effect.
      1 => POWERDOWN,  //= Read: Sleep/Deep-sleep or Deep                   power-down mode entered. Write: Writing a 1                   clears the SLEEPFLAG bit to 0.
    }
    11 => dpdflag {  //! Deep power-down flag
      0 => NODEEPPOWERDOWN,  //= Read: Deep power-down mode not                   entered. Write: No effect.
      1 => DEEPPOWERDOWN,  //= Read: Deep power-down mode entered.                   Write: Clear the Deep power-down                   flag.
    }
  },
  0x04 => reg32 gpreg0 {  //! General purpose register
    0..31 => gpdata,  //= Data retained during Deep power-down               mode.
  },
  0x08 => reg32 gpreg1 {  //! General purpose register
    0..31 => gpdata,  //= Data retained during Deep power-down               mode.
  },
  0x0c => reg32 gpreg2 {  //! General purpose register
    0..31 => gpdata,  //= Data retained during Deep power-down               mode.
  },
  0x10 => reg32 gpreg3 {  //! General purpose register
    0..31 => gpdata,  //= Data retained during Deep power-down               mode.
  },
  0x14 => reg32 gpreg4 {  //! General purpose register 4
    10 => wakeuphys {  //! WAKEUP pin hysteresis               enable
      1 => ENABLED,  //= Hysteresis for WAKEUP pin                   enabled.
      0 => DISABLED,  //= Hysteresis for WAKUP pin                   disabled.
    }
    11..31 => gpdata,  //= Data retained during Deep power-down               mode.
  },
});
ioregs! (FLASHCTRL @ 0x4003c000 = {  //! Product name title=UM10462 Chapter       title=LPC11U1x Flash programming firmware Modification       date=3/17/2011 Major revision=0 Minor       revision=3
  0x10 => reg32 flashcfg {  //! Flash memory access time configuration           register
    0..1 => flashtim {  //! Flash memory access time. FLASHTIM +1 is               equal to the number of system clocks used for flash               access.
      1 => E_1_SYSTEM_CLOCK_FLASH,  //= 1 system clock flash access time                   (for system clock frequencies of up to 20                   MHz).
      2 => E_2_SYSTEM_CLOCKS_FLAS,  //= 2 system clocks flash access time                   (for system clock frequencies of up to 40                   MHz).
      3 => E_3_SYSTEM_CLOCKS_FLAS,  //= 3 system clocks flash access time                   (for system clock frequencies of up to 50                   MHz).
    }
  },
  0x20 => reg32 fmsstart {  //! Signature start address           register
    0..16 => start,  //= Signature generation start address               (corresponds to AHB byte address               bits[20:4]).
  },
  0x24 => reg32 fmsstop {  //! Signature stop-address           register
    0..16 => stop,  //= BIST stop address divided by 16               (corresponds to AHB byte address               [20:4]).
    17 => sig_start {  //! Start control bit for signature               generation.
      0 => SIGNATURE_GENERATION,  //= Signature generation is                   stopped
      1 => INITIATE_SIGNATURE_G,  //= Initiate signature                   generation
    }
  },
  0x2c => reg32 fmsw0 {  //! Word 0 [31:0]
    0..31 => sw0_31_0: ro,  //= Word 0 of 128-bit signature (bits 31 to               0).
  },
  0x30 => reg32 fmsw1 {  //! Word 1 [63:32]
    0..31 => sw1_63_32: ro,  //= Word 1 of 128-bit signature (bits 63 to               32).
  },
  0x34 => reg32 fmsw2 {  //! Word 2 [95:64]
    0..31 => sw2_95_64: ro,  //= Word 2 of 128-bit signature (bits 95 to               64).
  },
  0x38 => reg32 fmsw3 {  //! Word 3 [127:96]
    0..31 => sw3_127_96: ro,  //= Word 3 of 128-bit signature (bits 127 to               96).
  },
  0xfe0 => reg32 fmstat {  //! Signature generation status           register
    2 => sig_done: ro,  //= When 1, a previously started signature               generation has completed. See FMSTATCLR register               description for clearing this flag.
  },
  0xfe8 => reg32 fmstatclr {  //! Signature generation status clear           register
    2 => sig_done_clr: wo,  //= Writing a 1 to this bits clears the               signature generation completion flag (SIG_DONE) in               the FMSTAT register.
  },
});
ioregs! (SPI0 @ 0x40040000 = {  //! SPI0
  0x00 => reg32 cr0 {  //! Control Register 0. Selects the serial clock           rate, bus type, and data size.
    0..3 => dss {  //! Data Size Select. This field controls               the number of bits transferred in each frame. Values               0000-0010 are not supported and should not be               used.
      3 => E_4_BIT_TRANSFER,  //= 4-bit transfer
      4 => E_5_BIT_TRANSFER,  //= 5-bit transfer
      5 => E_6_BIT_TRANSFER,  //= 6-bit transfer
      6 => E_7_BIT_TRANSFER,  //= 7-bit transfer
      7 => E_8_BIT_TRANSFER,  //= 8-bit transfer
      8 => E_9_BIT_TRANSFER,  //= 9-bit transfer
      9 => E_10_BIT_TRANSFER,  //= 10-bit transfer
      10 => E_11_BIT_TRANSFER,  //= 11-bit transfer
      11 => E_12_BIT_TRANSFER,  //= 12-bit transfer
      12 => E_13_BIT_TRANSFER,  //= 13-bit transfer
      13 => E_14_BIT_TRANSFER,  //= 14-bit transfer
      14 => E_15_BIT_TRANSFER,  //= 15-bit transfer
      15 => E_16_BIT_TRANSFER,  //= 16-bit transfer
    }
    4..5 => frf {  //! Frame Format.
      0 => SPI,  //= SPI
      1 => TI,  //= TI
      2 => MICROWIRE,  //= Microwire
    }
    6 => cpol {  //! Clock Out Polarity. This bit is only               used in SPI mode.
      0 => LOW,  //= SPI controller maintains the bus                   clock low between frames.
      1 => HIGH,  //= SPI controller maintains the bus                   clock high between frames.
    }
    7 => cpha {  //! Clock Out Phase. This bit is only used               in SPI mode.
      0 => FIRSTCLOCK,  //= SPI controller captures serial data                   on the first clock transition of the frame, that                   is, the transition away from the inter-frame                   state of the clock line.
      1 => SECONDCLOCK,  //= SPI controller captures serial data                   on the second clock transition of the frame, that                   is, the transition back to the inter-frame state                   of the clock line.
    }
    8..15 => scr,  //= Serial Clock Rate. The number of               prescaler output clocks per bit on the bus, minus               one. Given that CPSDVSR is the prescale divider, and               the APB clock PCLK clocks the prescaler, the bit               frequency is PCLK / (CPSDVSR X               [SCR+1]).
  },
  0x04 => reg32 cr1 {  //! Control Register 1. Selects master/slave and           other modes.
    0 => lbm {  //! Loop Back Mode.
      0 => NORMAL,  //= During normal                   operation.
      1 => LOOPBACK,  //= Serial input is taken from the                   serial output (MOSI or MISO) rather than the                   serial input pin (MISO or MOSI                   respectively).
    }
    1 => sse {  //! SPI Enable.
      0 => DISABLE,  //= The SPI controller is                   disabled.
      1 => ENABLE,  //= The SPI controller will interact                   with other devices on the serial bus. Software                   should write the appropriate control information                   to the other SPI/SSP registers and interrupt                   controller registers, before setting this                   bit.
    }
    2 => ms {  //! Master/Slave Mode.This bit can only be               written when the SSE bit is 0.
      0 => MASTER,  //= The SPI controller acts as a master                   on the bus, driving the SCLK, MOSI, and SSEL                   lines and receiving the MISO line.
      1 => SLAVE,  //= The SPI controller acts as a slave                   on the bus, driving MISO line and receiving SCLK,                   MOSI, and SSEL lines.
    }
    3 => sod,  //= Slave Output Disable. This bit is               relevant only in slave mode (MS = 1). If it is 1,               this blocks this SPI controller from driving the               transmit data line (MISO).
  },
  0x08 => reg32 dr {  //! Data Register. Writes fill the transmit           FIFO, and reads empty the receive FIFO.
    0..15 => data,  //= Write: software can write data to be               sent in a future frame to this register whenever the               TNF bit in the Status register is 1, indicating that               the Tx FIFO is not full. If the Tx FIFO was               previously empty and the SPI controller is not busy               on the bus, transmission of the data will begin               immediately. Otherwise the data written to this               register will be sent as soon as all previous data               has been sent (and received). If the data length is               less than 16 bit, software must right-justify the               data written to this register. Read: software can               read data from this register whenever the RNE bit in               the Status register is 1, indicating that the Rx FIFO               is not empty. When software reads this register, the               SPI controller returns data from the least recent               frame in the Rx FIFO. If the data length is less than               16 bit, the data is right-justified in this field               with higher order bits filled with 0s.
  },
  0x0c => reg32 sr {  //! Status Register
    0 => tfe: ro,  //= Transmit FIFO Empty. This bit is 1 is               the Transmit FIFO is empty, 0 if not.
    1 => tnf: ro,  //= Transmit FIFO Not Full. This bit is 0 if               the Tx FIFO is full, 1 if not.
    2 => rne: ro,  //= Receive FIFO Not Empty. This bit is 0 if               the Receive FIFO is empty, 1 if not.
    3 => rff: ro,  //= Receive FIFO Full. This bit is 1 if the               Receive FIFO is full, 0 if not.
    4 => bsy: ro,  //= Busy. This bit is 0 if the SPI               controller is idle, 1 if it is currently               sending/receiving a frame and/or the Tx FIFO is not               empty.
  },
  0x10 => reg32 cpsr {  //! Clock Prescale Register
    0..7 => cpsdvsr,  //= This even value between 2 and 254, by               which SPI_PCLK is divided to yield the prescaler               output clock. Bit 0 always reads as 0.
  },
  0x14 => reg32 imsc {  //! Interrupt Mask Set and Clear           Register
    0 => rorim,  //= Software should set this bit to enable               interrupt when a Receive Overrun occurs, that is,               when the Rx FIFO is full and another frame is               completely received. The ARM spec implies that the               preceding frame data is overwritten by the new frame               data when this occurs.
    1 => rtim,  //= Software should set this bit to enable               interrupt when a Receive Time-out condition occurs. A               Receive Time-out occurs when the Rx FIFO is not               empty, and no has not been read for a time-out               period. The time-out period is the same for master               and slave modes and is determined by the SSP bit               rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
    2 => rxim,  //= Software should set this bit to enable               interrupt when the Rx FIFO is at least half               full.
    3 => txim,  //= Software should set this bit to enable               interrupt when the Tx FIFO is at least half               empty.
  },
  0x18 => reg32 ris {  //! Raw Interrupt Status Register
    0 => rorris: ro,  //= This bit is 1 if another frame was               completely received while the RxFIFO was full. The               ARM spec implies that the preceding frame data is               overwritten by the new frame data when this               occurs.
    1 => rtris: ro,  //= This bit is 1 if the Rx FIFO is not               empty, and has not been read for a time-out period.               The time-out period is the same for master and slave               modes and is determined by the SSP bit rate: 32 bits               at PCLK / (CPSDVSR x [SCR+1]).
    2 => rxris: ro,  //= This bit is 1 if the Rx FIFO is at least               half full.
    3 => txris: ro,  //= This bit is 1 if the Tx FIFO is at least               half empty.
  },
  0x1c => reg32 mis {  //! Masked Interrupt Status           Register
    0 => rormis: ro,  //= This bit is 1 if another frame was               completely received while the RxFIFO was full, and               this interrupt is enabled.
    1 => rtmis: ro,  //= This bit is 1 if the Rx FIFO is not               empty, has not been read for a time-out period, and               this interrupt is enabled. The time-out period is the               same for master and slave modes and is determined by               the SSP bit rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
    2 => rxmis: ro,  //= This bit is 1 if the Rx FIFO is at least               half full, and this interrupt is               enabled.
    3 => txmis: ro,  //= This bit is 1 if the Tx FIFO is at least               half empty, and this interrupt is               enabled.
  },
  0x20 => reg32 icr {  //! SSPICR Interrupt Clear           Register
    0 => roric: wo,  //= Writing a 1 to this bit clears the frame               was received when RxFIFO was full               interrupt.
    1 => rtic: wo,  //= Writing a 1 to this bit clears the Rx               FIFO was not empty and has not been read for a               timeout period interrupt. The timeout period is the               same for master and slave modes and is determined by               the SSP bit rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
  },
});
ioregs! (IOCON @ 0x40044000 = {  //! Product name title=UM10398 Chapter       title=LPC1100XL series: I/O configuration (IOCONFIG)       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 iocon_pio2_6 {  //! I/O configuration for pin PIO2_6/           CT32B0_MAT1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_6.
      1 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x08 => reg32 iocon_pio2_0 {  //! I/O configuration for pin           PIO2_0/DTR/SSEL1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_0.
      1 => SELECT_FUNCTION_DTR_,  //= Select function DTR.
      2 => SELECT_FUNCTION_SSEL,  //= Select function SSEL1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x0c => reg32 iocon_reset_pio0_0 {  //! I/O configuration for pin           RESET/PIO0_0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_RES,  //= Selects function                   RESET.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x10 => reg32 iocon_pio0_1 {  //! I/O configuration for pin           PIO0_1/CLKOUT/CT32B0_MAT2
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_1.
      1 => SELECTS_FUNCTION_CLK,  //= Selects function                   CLKOUT.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT2.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x14 => reg32 iocon_pio1_8 {  //! I/O configuration for pin           PIO1_8/CT16B1_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_8.
      1 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B1_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x1c => reg32 iocon_pio0_2 {  //! I/O configuration for pin           PIO0_2/SSEL0/CT16B0_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_2.
      1 => SELECTS_FUNCTION_SSE,  //= Selects function                   SSEL0.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x20 => reg32 iocon_pio2_7 {  //! I/O configuration for pin PIO2_7/           CT32B0_MAT2/RXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_7.
      1 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT2.
      2 => SELECTS_FUNCTION_RXD,  //= Selects function RXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x24 => reg32 iocon_pio2_8 {  //! I/O configuration for pin PIO2_8/           CT32B0_MAT3/TXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_8.
      1 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT3.
      2 => SELECTS_FUNCTION_TXD,  //= Selects function TXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x28 => reg32 iocon_pio2_1 {  //! I/O configuration for pin           PIO2_1/DSR/SCK1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_1.
      1 => SELECT_FUNCTION_DSR_,  //= Select function DSR.
      2 => SELECT_FUNCTION_SCK1,  //= Select function SCK1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x2c => reg32 iocon_pio0_3 {  //! I/O configuration for pin           PIO0_3
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_3.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x30 => reg32 iocon_pio0_4 {  //! I/O configuration for pin           PIO0_4/SCL
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function PIO0_4 (open-drain                   pin).
      1 => SELECTS_I2C_FUNCTION,  //= Selects I2C function SCL (open-drain                   pin).
    }
    8..9 => i2cmode {  //! Selects I2C mode. Select Standard mode               (I2CMODE = 00, default) or Standard I/O functionality               (I2CMODE = 01) if the pin function is GPIO (FUNC =               000).
      0 => STANDARD_MODE_FAST,  //= Standard mode/ Fast-mode                   I2C.
      1 => STANDARD_IO_FUNCTION,  //= Standard I/O                   functionality
      2 => FAST_MODE_PLUS_I2C,  //= Fast-mode Plus I2C
    }
  },
  0x34 => reg32 iocon_pio0_5 {  //! I/O configuration for pin           PIO0_5/SDA
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function PIO0_5 (open-drain                   pin).
      1 => SELECTS_I2C_FUNCTION,  //= Selects I2C function SDA (open-drain                   pin).
    }
    8..9 => i2cmode {  //! Selects I2C mode. Select Standard mode               (I2CMODE = 00, default) or Standard I/O functionality               (I2CMODE = 01) if the pin function is GPIO (FUNC =               000).
      0 => STANDARD_MODE_FAST,  //= Standard mode/ Fast-mode                   I2C.
      1 => STANDARD_IO_FUNCTION,  //= Standard I/O                   functionality
      2 => FAST_MODE_PLUS_I2C,  //= Fast-mode Plus I2C
    }
  },
  0x38 => reg32 iocon_pio1_9 {  //! I/O configuration for pin           PIO1_9/CT16B1_MAT0/ MOSI1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_9.
      1 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B1_MAT0.
      2 => SELECTS_FUNCTION_MOS,  //= Selects function                   MOSI1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x3c => reg32 iocon_pio3_4 {  //! I/O configuration for pin PIO3_4/           CT16B0_CAP1/RXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_4.
      1 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_CAP1.
      2 => SELECTS_FUNCTION_RXD,  //= Selects function RXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x40 => reg32 iocon_pio2_4 {  //! I/O configuration for pin PIO2_4/           CT16B1_MAT1/ SSEL1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_4.
      1 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B1_MAT1.
      2 => SELECTS_FUNCTION_SSE,  //= Selects function                   SSEL1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x44 => reg32 iocon_pio2_5 {  //! I/O configuration for pin PIO2_5/           CT32B0_MAT0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_5.
      1 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x48 => reg32 iocon_pio3_5 {  //! I/O configuration for pin PIO3_5/           CT16B1_CAP1/TXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_5.
      1 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B1_CAP1.
      2 => SELECTS_FUNCTION_TXD,  //= Selects function TXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x4c => reg32 iocon_pio0_6 {  //! I/O configuration for pin           PIO0_6/SCK0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_6.
      2 => SELECTS_FUNCTION_SCK,  //= Selects function SCK0 (only if pin                   PIO0_6/SCK0 selected in Table 147).
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x50 => reg32 iocon_pio0_7 {  //! I/O configuration for pin           PIO0_7/CTS
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_7.
      1 => SELECT_FUNCTION_CTS_,  //= Select function CTS.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x54 => reg32 iocon_pio2_9 {  //! I/O configuration for pin PIO2_9/           CT32B0_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_9.
      1 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x58 => reg32 iocon_pio2_10 {  //! I/O configuration for pin           PIO2_10
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_10.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x5c => reg32 iocon_pio2_2 {  //! I/O configuration for pin           PIO2_2/DCD/MISO1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_2.
      1 => SELECT_FUNCTION_DCD_,  //= Select function DCD.
      2 => SELECT_FUNCTION_MISO,  //= Select function MISO1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x60 => reg32 iocon_pio0_8 {  //! I/O configuration for pin           PIO0_8/MISO0/CT16B0_MAT0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_8.
      1 => SELECTS_FUNCTION_MIS,  //= Selects function                   MISO0.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x64 => reg32 iocon_pio0_9 {  //! I/O configuration for pin           PIO0_9/MOSI0/CT16B0_MAT1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_9.
      1 => SELECTS_FUNCTION_MOS,  //= Selects function                   MOSI0.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x68 => reg32 iocon_swclk_pio0_10 {  //! I/O configuration for pin SWCLK/PIO0_10/           SCK0/CT16B0_MAT2
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_SWC,  //= Selects function                   SWCLK.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_10.
      2 => SELECTS_FUNCTION_SCK,  //= Selects function SCK0 (only if pin                   SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table                   147).
      3 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT2.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x6c => reg32 iocon_pio1_10 {  //! I/O configuration for pin           PIO1_10/AD6/CT16B1_MAT1/ MISO1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_10.
      1 => SELECTS_FUNCTION_AD6,  //= Selects function AD6.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B1_MAT1.
      3 => SELECTS_FUNCTION_MIS,  //= Selects function                   MISO1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x70 => reg32 iocon_pio2_11 {  //! I/O configuration for pin PIO2_11/SCK0/           CT32B0_CAP1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_11.
      1 => SELECT_FUNCTION_SCK0,  //= Select function SCK0 (only if pin                   PIO2_11/SCK0 selected in Table                   147).
      2 => SELECT_FUNCTION_CT32,  //= Select function                   CT32B0_CAP1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x74 => reg32 iocon_r_pio0_11 {  //! I/O configuration for pin           R/PIO0_11/AD0/CT32B0_MAT3
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_R_,  //= Selects function R. This function is                   reserved. Select one of the alternate functions                   below.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO0_11.
      2 => SELECTS_FUNCTION_AD0,  //= Selects function AD0.
      3 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT3.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x78 => reg32 iocon_r_pio1_0 {  //! I/O configuration for pin           R/PIO1_0/AD1/CT32B1_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_R_,  //= Selects function R. This function is                   reserved. Select one of the alternate functions                   below.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_0.
      2 => SELECTS_FUNCTION_AD1,  //= Selects function AD1.
      3 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x7c => reg32 iocon_r_pio1_1 {  //! I/O configuration for pin           R/PIO1_1/AD2/CT32B1_MAT0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_R_,  //= Selects function R. This function is                   reserved. Select one of the alternate functions                   below.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_1.
      2 => SELECTS_FUNCTION_AD2,  //= Selects function AD2.
      3 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_MAT0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x80 => reg32 iocon_r_pio1_2 {  //! I/O configuration for pin           R/PIO1_2/AD3/CT32B1_MAT1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_R_,  //= Selects function R. This function is                   reserved. Select one of the alternate functions                   below.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_2.
      2 => SELECTS_FUNCTION_AD3,  //= Selects function AD3.
      3 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_MAT1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x84 => reg32 iocon_pio3_0 {  //! I/O configuration for pin           PIO3_0/DTR/CT16B0_MAT0/TXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_0.
      1 => SELECTS_FUNCTION_DTR,  //= Selects function DTR.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT0.
      3 => SELECTS_FUNCTION_TXD,  //= Selects function TXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x88 => reg32 iocon_pio3_1 {  //! I/O configuration for pin           PIO3_1/DSR/CT16B0_MAT1/RXD
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_1.
      1 => SELECTS_FUNCTION_DSR,  //= Selects function DSR.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT1.
      3 => SELECTS_FUNCTION_RXD,  //= Selects function RXD.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x8c => reg32 iocon_pio2_3 {  //! I/O configuration for pin           PIO2_3/RI/MOSI1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO2_3.
      1 => SELECTS_FUNCTION_RI_,  //= Selects function RI.
      2 => SELECTS_FUNCTION_MOS,  //= Selects function                   MOSI1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x90 => reg32 iocon_swdio_pio1_3 {  //! I/O configuration for pin           SWDIO/PIO1_3/AD4/CT32B1_MAT2
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_SWD,  //= Selects function                   SWDIO.
      1 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_3.
      2 => SELECTS_FUNCTION_AD4,  //= Selects function AD4.
      3 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_MAT2.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x94 => reg32 iocon_pio1_4 {  //! I/O configuration for pin           PIO1_4/AD5/CT32B1_MAT3
    0..2 => func {  //! Selects pin function. This pin functions               as WAKEUP pin if the LPC111x/LPC11Cxx is in Deep               power-down mode regardless of the value of FUNC. All               other values are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_4.
      1 => SELECTS_FUNCTION_AD5,  //= Selects function AD5.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_MAT3.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x98 => reg32 iocon_pio1_11 {  //! I/O configuration for pin           PIO1_11/AD7/CT32B1_CAP1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_11.
      1 => SELECTS_FUNCTION_AD7,  //= Selects function AD7.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B1_CAP1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    7 => admode {  //! Selects Analog/Digital               mode
      0 => ANALOG_INPUT_MODE,  //= Analog input mode
      1 => DIGITAL_FUNCTIONAL_M,  //= Digital functional                   mode
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0x9c => reg32 iocon_pio3_2 {  //! I/O configuration for pin PIO3_2/DCD/           CT16B0_MAT2/SCK1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_2.
      1 => SELECTS_FUNCTION_DCD,  //= Selects function DCD.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_MAT2.
      3 => SELECTS_FUNCTION_SCK,  //= Selects function SCK1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0xa0 => reg32 iocon_pio1_5 {  //! I/O configuration for pin           PIO1_5/RTS/CT32B0_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_5.
      1 => SELECTS_FUNCTION_RTS,  //= Selects function RTS.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0xa4 => reg32 iocon_pio1_6 {  //! I/O configuration for pin           PIO1_6/RXD/CT32B0_MAT0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_6.
      1 => SELECTS_FUNCTION_RXD,  //= Selects function RXD.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0xa8 => reg32 iocon_pio1_7 {  //! I/O configuration for pin           PIO1_7/TXD/CT32B0_MAT1
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO1_7.
      1 => SELECTS_FUNCTION_TXD,  //= Selects function TXD.
      2 => SELECTS_FUNCTION_CT3,  //= Selects function                   CT32B0_MAT1.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0xac => reg32 iocon_pio3_3 {  //! I/O configuration for pin PIO3_3/RI/           CT16B0_CAP0
    0..2 => func {  //! Selects pin function. All other values               are reserved.
      0 => SELECTS_FUNCTION_PIO,  //= Selects function                   PIO3_3.
      1 => SELECTS_FUNCTION_RI_,  //= Selects function RI.
      2 => SELECTS_FUNCTION_CT1,  //= Selects function                   CT16B0_CAP0.
    }
    3..4 => mode {  //! Selects function mode (on-chip               pull-up/pull-down resistor control).
      0 => INACTIVE_NO_PULL_DO,  //= Inactive (no pull-down/pull-up                   resistor enabled).
      1 => PULL_DOWN_RESISTOR_E,  //= Pull-down resistor                   enabled.
      2 => PULL_UP_RESISTOR_ENA,  //= Pull-up resistor                   enabled.
      3 => REPEATER_MODE_,  //= Repeater mode.
    }
    5 => hys {  //! Hysteresis.
      0 => DISABLE_,  //= Disable.
      1 => ENABLE_,  //= Enable.
    }
    10 => od {  //! Selects pseudo open-drain               mode.
      0 => STANDARD_GPIO_OUTPUT,  //= Standard GPIO output
      1 => OPEN_DRAIN_OUTPUT,  //= Open-drain output
    }
  },
  0xb0 => reg32 iocon_sck0_loc {  //! SCK0 pin location select           register
    0..1 => sckloc {  //! Selects pin location for SCK0               function.
      0 => SELECTS_SCK0_FUNCTIO_PIO0_10,  //= Selects SCK0 function in pin                   location SWCLK/PIO0_10/SCK0/CT16B0_MAT2 (see                   Table 129).
      1 => SELECTS_SCK0_FUNCTIO_PIO2_11,  //= Selects SCK0 function in pin                   location PIO2_11/SCK0 (see Table                   131).
      2 => SELECTS_SCK0_FUNCTIO_PIO0_6,  //= Selects SCK0 function in pin                   location PIO0_6/SCK0 (see Table                   122).
    }
  },
  0xb4 => reg32 iocon_dsr_loc {  //! DSR pin location select           register
    0..1 => dsrloc {  //! Selects pin location for DSR               function.
      0 => SELECTS_DSR_FUNCTIO_PIO2_1,  //= Selects DSR function in pin location                   PIO2_1/DSR/SCK1 (see Table 113).
      1 => SELECTS_DSR_FUNCTION_PIO3_1,  //= Selects DSR function in pin location                   PIO3_1/DSR (see Table 137).
    }
  },
  0xb8 => reg32 iocon_dcd_loc {  //! DCD pin location select           register
    0..1 => dcdloc {  //! Selects pin location for DCD               function.
      0 => SELECTS_DCD_FUNCTIO_PIO2_2,  //= Selects DCD function in pin location                   PIO2_2/DCD/MISO1 (see Table 126).
      1 => SELECTS_DCD_FUNCTION_PIO3_2,  //= Selects DCD function in pin location                   PIO3_2/DCD (see Table 142).
    }
  },
  0xbc => reg32 iocon_ri_loc {  //! RI pin location select           register
    0..1 => riloc {  //! Selects pin location for RI               function.
      0 => SELECTS_RI_FUNCTION_PIO2_3,  //= Selects RI function in pin location                   PIO2_3/RI/MOSI1 (see Table 138).
      1 => SELECTS_RI_FUNCTION_PIO3_3,  //= Selects RI function in pin location                   PIO3_3/RI (see Table 146).
    }
  },
  0x18 => reg32 iocon_ssel1_loc {  //! SSEL1 pin location select           register
    0..1 => ssel1loc {  //! Selects pin location for SSEL1               function.
      0 => SELECTS_SSEL1_FUNCTI_PIO2_2,  //= Selects SSEL1 function in pin                   location PIO2_2/DCD/MISO1 (see Table                   126).
      1 => SELECTS_SSEL1_FUNCTI_PIO2_4,  //= Selects SSEL1 function in pin                   location PIO2_4/CT16B1_MAT1/SSEL1 (see Table                   119).
    }
  },
  0xc0 => reg32 iocon_ct16b0_cap0_loc {  //! CT16B0_CAP0 pin location select           register
    0..1 => ct16b0_cap0loc {  //! Selects pin location for CT16B0_CAP0               function.
      0 => SELECTS_CT16B0_CAP0_PIO0_2,  //= Selects CT16B0_CAP0 function in pin                   location PIO0_2/SSEL0/CT16B0_CAP0 (see Table                   110).
      1 => SELECTS_CT16B0_CAP0_PIO3_3,  //= Selects CT16B0_CAP0 function in pin                   location PIO3_3/RI/CT16B0 (see Table                   146).
    }
  },
  0xc4 => reg32 iocon_sck1_loc {  //! SCK1 pin location select           register
    0..1 => sck1loc {  //! Selects pin location for SCK1               function.
      0 => SELECTS_SCK1_FUNCTIO_PIO2_1,  //= Selects SCK1 function in pin                   location PIO2_1/DSR/SCK1 (see Table                   113).
      1 => SELECTS_SCK1_FUNCTIO_PIO3_2,  //= Selects SCK1 function in pin                   location PIO3_2/DCD/CT16B0_MAT2/SCK1 (see Table                   142).
    }
  },
  0xc8 => reg32 iocon_miso1_loc {  //! MISO1 pin location select           register
    0..1 => miso1loc {  //! Selects pin location for the MISO1               function.
      0 => SELECTS_MISO1_FUNCTI_PIO2_2,  //= Selects MISO1 function in pin                   location PIO2_2/DCD/MISO1 (see Table                   126).
      1 => SELECTS_MISO1_FUNCTI_PIO1_10,  //= Selects MISO1 function in pin                   location PIO1_10/AD6/CT16B1_MAT1/MISO1 (see Table                   130).
    }
  },
  0xcc => reg32 iocon_mosi1_loc {  //! MOSI1 pin location select           register
    0..1 => mosi1loc {  //! Selects pin location for the MOSI1               function.
      0 => SELECTS_MOSI1_FUNCTI_PIO2_3,  //= Selects MOSI1 function in pin                   location PIO2_3/RI/MOSI1 (see Table                   138).
      1 => SELECTS_MOSI1_FUNCTI_PIO1_9,  //= Selects MOSI1 function in pin                   location PIO1_9/CT16B1_MAT0/MOSI1 (see Table                   117).
    }
  },
  0xd0 => reg32 iocon_ct32b0_cap0_loc {  //! CT32B0_CAP0 pin location select           register
    0..1 => ct32b0_cap0loc {  //! Selects pin location for the CT32B0_CAP0               function.
      0 => SELECTS_CT32B0_CAP0_PIO1_5,  //= Selects CT32B0_CAP0 function in pin                   location PIO1_5/RTS/CT32B0_CAP0 (see Table                   143).
      1 => SELECTS_CT32B0_CAP0_PIO2_9,  //= Selects CT32B0_CAP0 function in pin                   location PIO2_9/CT32B0_CAP0 (Table                   124).
    }
  },
  0xd4 => reg32 iocon_rxd_loc {  //! RXD pin location select           register
    0..1 => rxdloc {  //! Selects pin location for the RXD               function.
      0 => SELECTS_RXD_FUNCTION_PIO1_6,  //= Selects RXD function in pin location                   PIO1_6/RXD/CT32B0_MAT0 (see Table                   144).
      1 => SELECTS_RXD_FUNCTION_PIO2_7,  //= Selects RXD function in pin location                   PIO2_7/CT32B0_MAT2/RXD (see Table                   111).
      2 => SELECTS_RXD_FUNCTION_PIO3_1,  //= Selects RXD function in pin location                   PIO3_1/DSR/CT16B0_MAT1/RXD (see Table                   137).
      3 => SELECTS_RXD_FUNCTION_PIO3_4,  //= Selects RXD function in pin location                   PIO3_4/CT16B0_CAP1/RXD (see Table                   118).
    }
  },
});
ioregs! (SYSCON @ 0x40048000 = {  //! Product name title=UM10398 Chapter       title=LPC111x/LPC11Cxx System configuration (SYSCON)       Modification date=2/22/2012 Major revision=8 Minor       revision=not available
  0x00 => reg32 sysmemremap {  //! System memory remap
    0..1 => map {  //! System memory remap
      0 => BOOT_LOADER_MODE_IN,  //= Boot Loader Mode. Interrupt vectors                   are re-mapped to Boot ROM.
      1 => USER_RAM_MODE_INTER,  //= User RAM Mode. Interrupt vectors are                   re-mapped to Static RAM.
      2 => USER_FLASH_MODE_INT,  //= User Flash Mode. Interrupt vectors                   are not re-mapped and reside in                   Flash.
    }
  },
  0x04 => reg32 presetctrl {  //! Peripheral reset control
    0 => ssp0_rst_n {  //! SPI0 reset control
      0 => SPIO0RESET,  //= Resets the SPI0                   peripheral.
      1 => SPIO0NORESET,  //= SPI0 reset                   de-asserted.
    }
    1 => i2c_rst_n {  //! I2C reset control
      0 => I2CRESET,  //= Resets the I2C                   peripheral.
      1 => I2CNORESET,  //= I2C reset de-asserted.
    }
    2 => ssp1_rst_n {  //! SPI1 reset control
      0 => SPI1RESET,  //= Resets the SPI1                   peripheral.
      1 => SPI2NORESET,  //= SPI1 reset                   de-asserted.
    }
    3 => can_rst_n {  //! C_CAN reset control. See Section 3.1 for               part specific details.
      0 => CANRESET,  //= Resets the C_CAN                   peripheral.
      1 => CANNORESET,  //= C_CAN reset                   de-asserted.
    }
  },
  0x08 => reg32 syspllctrl {  //! System PLL control
    0..4 => msel,  //= Feedback divider value. The division               value M is the programmed MSEL value + 1. 00000:               Division ratio M = 1 to 11111: Division ratio M =               32.
    5..6 => psel {  //! Post divider ratio P. The division ratio               is 2 x P.
      0 => P_EQ_1,  //= P = 1
      1 => P_EQ_2,  //= P = 2
      2 => P_EQ_4,  //= P = 4
      3 => P_EQ_8,  //= P = 8
    }
  },
  0x0c => reg32 syspllstat {  //! System PLL status
    0 => lock: ro {  //! PLL lock status
      0 => PLL_NOT_LOCKED,  //= PLL not locked
      1 => PLL_LOCKED,  //= PLL locked
    }
  },
  0x20 => reg32 sysoscctrl {  //! System oscillator control
    0 => bypass {  //! Bypass system oscillator
      0 => NOBYPASS,  //= Oscillator is not                   bypassed.
      1 => BYPASS_ENABLED_PLL_,  //= Bypass enabled. PLL input                   (sys_osc_clk) is fed directly from the XTALIN and                   XTALOUT pins.
    }
    1 => freqrange {  //! Determines frequency range for Low-power               oscillator.
      0 => LOW,  //= 1 - 20 MHz frequency                   range.
      1 => HIGH,  //= 15 - 25 MHz frequency                   range
    }
  },
  0x24 => reg32 wdtoscctrl {  //! Watchdog oscillator control
    0..4 => divsel,  //= Select divider for Fclkana. wdt_osc_clk               = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL)               = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 +               DIVSEL) = 64
    5..8 => freqsel {  //! Select watchdog oscillator analog output               frequency (Fclkana).
      1 => E_0_5_MHZ,  //= 0.5 MHz
      2 => E_0_8_MHZ,  //= 0.8 MHz
      3 => E_1_1_MHZ,  //= 1.1 MHz
      4 => E_1_4_MHZ,  //= 1.4 MHz
      5 => E_1_6_MHZ,  //= 1.6 MHz
      6 => E_1_8_MHZ,  //= 1.8 MHz
      7 => E_2_0_MHZ,  //= 2.0 MHz
      8 => E_2_2_MHZ,  //= 2.2 MHz
      9 => E_2_4_MHZ,  //= 2.4 MHz
      10 => E_2_6_MHZ,  //= 2.6 MHz
      11 => E_2_7_MHZ,  //= 2.7 MHz
      12 => E_2_9_MHZ,  //= 2.9 MHz
      13 => E_3_1_MHZ,  //= 3.1 MHz
      14 => E_3_2_MHZ,  //= 3.2 MHz
      15 => E_3_4_MHZ,  //= 3.4 MHz
    }
  },
  0x28 => reg32 ircctrl {  //! IRC control
    0..7 => trim,  //= Trim value
  },
  0x30 => reg32 sysrststat {  //! System reset status register
    0 => por: ro {  //! POR reset status
      0 => NO_POR_DETECTED_,  //= No POR detected.
      1 => POR_DETECTED_WRITIN,  //= POR detected. Writing a one clears                   this reset.
    }
    1 => extrst: ro {  //! Status of the external RESET               pin.
      0 => NO_RESET_EVENT_DETEC,  //= No RESET event                   detected.
      1 => RESET_DETECTED_WRIT,  //= RESET detected. Writing a one clears                   this reset.
    }
    2 => wdt: ro {  //! Status of the Watchdog               reset
      0 => NO_WDT_RESET_DETECTE,  //= No WDT reset detected.
      1 => WDT_RESET_DETECTED_,  //= WDT reset detected. Writing a one                   clears this reset.
    }
    3 => bod: ro {  //! Status of the Brown-out detect               reset
      0 => NO_BOD_RESET_DETECTE,  //= No BOD reset detected.
      1 => BOD_RESET_DETECTED_,  //= BOD reset detected. Writing a one                   clears this reset.
    }
    4 => sysrst: ro {  //! Status of the software system               reset
      0 => NO_SYSTEM_RESET_DETE,  //= No System reset                   detected.
      1 => SYSTEM_RESET_DETECTE,  //= System reset detected. Writing a one                   clears this reset.
    }
  },
  0x40 => reg32 syspllclksel {  //! System PLL clock source select
    0..1 => sel {  //! System PLL clock source
      0 => IRC_OSCILLATOR,  //= IRC oscillator
      1 => SYSTEM_OSCILLATOR,  //= System oscillator
    }
  },
  0x44 => reg32 syspllclkuen {  //! System PLL clock source update           enable
    0 => ena {  //! Enable system PLL clock source               update
      0 => NO_CHANGE,  //= No change
      1 => UPDATE_CLOCK_SOURCE,  //= Update clock source
    }
  },
  0x70 => reg32 mainclksel {  //! Main clock source select
    0..1 => sel {  //! Clock source for main               clock
      0 => IRC_OSCILLATOR,  //= IRC oscillator
      1 => INPUT_CLOCK_TO_SYSTE,  //= Input clock to system                   PLL
      2 => WDT_OSCILLATOR,  //= WDT oscillator
      3 => SYSTEM_PLL_CLOCK_OUT,  //= System PLL clock out
    }
  },
  0x74 => reg32 mainclkuen {  //! Main clock source update           enable
    0 => ena {  //! Enable main clock source               update
      0 => NO_CHANGE,  //= No change
      1 => UPDATE_CLOCK_SOURCE,  //= Update clock source
    }
  },
  0x78 => reg32 sysahbclkdiv {  //! System AHB clock divider
    0..7 => div,  //= System AHB clock divider values 0:               System clock disabled. 1: Divide by 1. to 255: Divide               by 255.
  },
  0x80 => reg32 sysahbclkctrl {  //! System AHB clock control
    0 => sys {  //! Enables clock for AHB to APB bridge, to               the AHB matrix, to the Cortex-M0 FCLK and HCLK, to               the SysCon, and to the PMU. This bit is read               only.
      1 => ENABLE,  //= Enable
    }
    1 => rom {  //! Enables clock for ROM.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    2 => ram {  //! Enables clock for RAM.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    3 => flashreg {  //! Enables clock for flash register               interface.
      0 => DISABLED,  //= Disabled
      1 => ENABLED,  //= Enabled
    }
    4 => flasharray {  //! Enables clock for flash array               access.
      0 => DISABLED,  //= Disabled
      1 => ENABLED,  //= Enabled
    }
    5 => i2c {  //! Enables clock for I2C.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    6 => gpio {  //! Enables clock for GPIO.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    7 => ct16b0 {  //! Enables clock for 16-bit counter/timer               0.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    8 => ct16b1 {  //! Enables clock for 16-bit counter/timer               1.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    9 => ct32b0 {  //! Enables clock for 32-bit counter/timer               0.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    10 => ct32b1 {  //! Enables clock for 32-bit counter/timer               1.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    11 => ssp0 {  //! Enables clock for SPI0.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    12 => uart {  //! Enables clock for UART. See Section 3.1               for part specific details.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    13 => adc {  //! Enables clock for ADC.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    15 => wdt {  //! Enables clock for WDT.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    16 => iocon {  //! Enables clock for I/O configuration               block.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    17 => can {  //! Enables clock for C_CAN. See Section 3.1               for part specific details.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
    18 => ssp1 {  //! Enables clock for SPI1.
      0 => DISABLE,  //= Disable
      1 => ENABLE,  //= Enable
    }
  },
  0x94 => reg32 ssp0clkdiv {  //! SPI0 clock divider
    0..7 => div,  //= SPI0_PCLK clock divider values 0:               Disable SPI0_PCLK. 1: Divide by 1. to 255: Divide by               255.
  },
  0x98 => reg32 uartclkdiv {  //! UART clock divder
    0..7 => div,  //= UART_PCLK clock divider values 0:               Disable UART_PCLK. 1: Divide by 1. to 255: Divide by               255.
  },
  0x9c => reg32 ssp1clkdiv {  //! SPI1 clock divder
    0..7 => div,  //= SPI1_PCLK clock divider values 0:               Disable SPI1_PCLK. 1: Divide by 1. to 255: Divide by               255.
  },
  0xd0 => reg32 wdtclksel {  //! WDT clock source select
    0..1 => sel {  //! WDT clock source
      0 => IRC_OSCILLATOR,  //= IRC oscillator
      1 => MAIN_CLOCK,  //= Main clock
      2 => WATCHDOG_OSCILLATOR,  //= Watchdog oscillator
    }
  },
  0xd4 => reg32 wdtclkuen {  //! WDT clock source update enable
    0 => ena {  //! Enable WDT clock source               update
      0 => NO_CHANGE,  //= No change
      1 => UPDATE_CLOCK_SOURCE,  //= Update clock source
    }
  },
  0xd8 => reg32 wdtclkdiv {  //! WDT clock divider
    0..7 => div,  //= WDT clock divider values 0: Disable               WDCLK. 1: Divide by 1. to 255: Divide by               255.
  },
  0xe0 => reg32 clkoutclksel {  //! CLKOUT clock source select
    0..1 => sel {  //! CLKOUT clock source
      0 => IRC_OSCILLATOR,  //= IRC oscillator
      1 => SYSTEM_OSCILLATOR,  //= System oscillator
      2 => WATCHDOG_OSCILLATOR,  //= Watchdog oscillator
      3 => MAIN_CLOCK,  //= Main clock
    }
  },
  0xe4 => reg32 clkoutuen {  //! CLKOUT clock source update           enable
    0 => ena {  //! Enable CLKOUT clock source               update
      0 => NO_CHANGE,  //= No change
      1 => UPDATE_CLOCK_SOURCE,  //= Update clock source
    }
  },
  0xe8 => reg32 clkoutclkdiv {  //! CLKOUT clock divider
    0..7 => div,  //= Clock output divider values 0: Disable               CLKOUT. 1: Divide by 1. to 255: Divide by               255.
  },
  0x100 => reg32 pioporcap0 {  //! POR captured PIO status 0
    0..11 => cappio0_n: ro,  //= Raw reset status input PIO0_n: PIO0_11               to PIO0_0
    12..23 => cappio1_n: ro,  //= Raw reset status input PIO1_n: PIO1_11               to PIO1_0
    24..31 => cappio2_n: ro,  //= Raw reset status input PIO2_n: PIO2_7 to               PIO2_0
  },
  0x104 => reg32 pioporcap1 {  //! POR captured PIO status 1
    0 => cappio2_8: ro,  //= Raw reset status input               PIO2_8
    1 => cappio2_9: ro,  //= Raw reset status input               PIO2_9
    2 => cappio2_10: ro,  //= Raw reset status input               PIO2_10
    3 => cappio2_11: ro,  //= Raw reset status input               PIO2_11
    4 => cappio3_0: ro,  //= Raw reset status input               PIO3_0
    5 => cappio3_1: ro,  //= Raw reset status input               PIO3_1
    6 => cappio3_2: ro,  //= Raw reset status input               PIO3_2
    7 => cappio3_3: ro,  //= Raw reset status input               PIO3_3
    8 => cappio3_4: ro,  //= Raw reset status input               PIO3_4
    9 => cappio3_5: ro,  //= Raw reset status input               PIO3_5
  },
  0x150 => reg32 bodctrl {  //! BOD control
    0..1 => bodrstlev {  //! BOD reset level
      0 => LEVEL_0_THE_RESET_A,  //= Level 0: The reset assertion                   threshold voltage is 1.46 V; the reset                   de-assertion threshold voltage is 1.63                   V.
      1 => LEVEL_1_THE_RESET_A,  //= Level 1: The reset assertion                   threshold voltage is 2.06 V; the reset                   de-assertion threshold voltage is 2.15                   V.
      2 => LEVEL_2_THE_RESET_A,  //= Level 2: The reset assertion                   threshold voltage is 2.35 V; the reset                   de-assertion threshold voltage is 2.43                   V.
      3 => LEVEL_3_THE_RESET_A,  //= Level 3: The reset assertion                   threshold voltage is 2.63 V; the reset                   de-assertion threshold voltage is 2.71                   V.
    }
    2..3 => bodintval {  //! BOD interrupt level
      0 => LEVEL_0_THE_INTERRU,  //= Level 0: The interrupt assertion                   threshold voltage is 1.65 V; the interrupt                   de-assertion threshold voltage is 1.80                   V.
      1 => LEVEL_1THE_INTERRUP,  //= Level 1:The interrupt assertion                   threshold voltage is 2.22 V; the interrupt                   de-assertion threshold voltage is 2.35                   V.
      2 => LEVEL_2_THE_INTERRU,  //= Level 2: The interrupt assertion                   threshold voltage is 2.52 V; the interrupt                   de-assertion threshold voltage is 2.66                   V.
      3 => LEVEL_3_THE_INTERRU,  //= Level 3: The interrupt assertion                   threshold voltage is 2.80 V; the interrupt                   de-assertion threshold voltage is 2.90                   V.
    }
    4 => bodrstena {  //! BOD reset enable
      0 => DISABLE_RESET_FUNCTI,  //= Disable reset                   function.
      1 => ENABLE_RESET_FUNCTIO,  //= Enable reset function.
    }
  },
  0x154 => reg32 systckcal {  //! System tick counter           calibration
    0..25 => cal,  //= System tick timer calibration               value
  },
  0x174 => reg32 nmisrc {  //! NMI source selection
    0..4 => irqno,  //= The IRQ number of the interrupt that               acts as the Non-Maskable Interrupt (NMI) if bit 31 in               this register is 1. See Table 54 for the list of               interrupt sources and their IRQ               numbers.
    31 => nmien,  //= Write a 1 to this bit to enable the               Non-Maskable Interrupt (NMI) source selected by bits               4:0.
  },
  0x200 => reg32 startaprp0 {  //! Start logic edge control register           0
    0 => aprpio0_0,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    1 => aprpio0_1,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    2 => aprpio0_2,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    3 => aprpio0_3,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    4 => aprpio0_4,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    5 => aprpio0_5,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    6 => aprpio0_6,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    7 => aprpio0_7,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    8 => aprpio0_8,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    9 => aprpio0_9,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    10 => aprpio0_10,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    11 => aprpio0_11,  //= Edge select for start logic input               PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising               edge
    12 => aprpio1_0,  //= Edge select for start logic input PIO1_0               0 = Falling edge 1 = Rising edge
  },
  0x204 => reg32 starterp0 {  //! Start logic signal enable register           0
    0 => erpio0_0,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    1 => erpio0_1,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    2 => erpio0_2,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    3 => erpio0_3,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    4 => erpio0_4,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    5 => erpio0_5,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    6 => erpio0_6,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    7 => erpio0_7,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    8 => erpio0_8,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    9 => erpio0_9,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    10 => erpio0_10,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    11 => erpio0_11,  //= Enable start signal for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 =               Enabled
    12 => erpio1_0,  //= Enable start signal for start logic               input PIO1_0 0 = Disabled 1 = Enabled
  },
  0x208 => reg32 startrsrp0clr {  //! Start logic reset register 0
    0 => rsrpio0_0: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    1 => rsrpio0_1: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    2 => rsrpio0_2: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    3 => rsrpio0_3: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    4 => rsrpio0_4: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    5 => rsrpio0_5: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    6 => rsrpio0_6: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    7 => rsrpio0_7: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    8 => rsrpio0_8: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    9 => rsrpio0_9: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    10 => rsrpio0_10: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    11 => rsrpio0_11: wo,  //= Start signal reset for start logic input               PIO0_n:PIO0_11 to PIO0_0 0 = Do nothing. 1 = Writing               1 resets the start signal.
    12 => rsrpio1_0: wo,  //= Start signal reset for start logic input               PIO1_0 0 = Do nothing. 1 = Writing 1 resets the start               signal.
  },
  0x20c => reg32 startsrp0 {  //! Start logic status register 0
    0 => srpio0_0: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    1 => srpio0_1: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    2 => srpio0_2: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    3 => srpio0_3: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    4 => srpio0_4: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    5 => srpio0_5: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    6 => srpio0_6: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    7 => srpio0_7: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    8 => srpio0_8: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    9 => srpio0_9: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    10 => srpio0_10: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    11 => srpio0_11: ro,  //= Start signal status for start logic               input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal               received. 1 = Start signal pending.
    12 => srpio1_0: ro,  //= Start signal status for start logic               input PIO1_0 0 = No start signal received. 1 = Start               signal pending.
  },
  0x230 => reg32 pdsleepcfg {  //! Power-down states in Deep-sleep           mode
    0..2 => notused0,  //= Reserved. Always write these bits as               111.
    3 => bod_pd {  //! BOD power-down control in Deep-sleep               mode, see Table 40.
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    4..5 => notused1,  //= Reserved. Always write these bits as               11.
    6 => wdtosc_pd {  //! Watchdog oscillator power control in               Deep-sleep mode, see Table 40.
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    7 => notused2,  //= Reserved. Always write this bit as               1.
    8..10 => notused3,  //= Reserved. Always write these bits as               000.
    11..12 => notused4,  //= Reserved. Always write these bits as               11.
  },
  0x234 => reg32 pdawakecfg {  //! Power-down states after wake-up from           Deep-sleep mode
    0 => ircout_pd {  //! IRC oscillator output wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    1 => irc_pd {  //! IRC oscillator power-down wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    2 => flash_pd {  //! Flash wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    3 => bod_pd {  //! BOD wake-up configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    4 => adc_pd {  //! ADC wake-up configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    5 => sysosc_pd {  //! System oscillator wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    6 => wdtosc_pd {  //! Watchdog oscillator wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    7 => syspll_pd {  //! System PLL wake-up               configuration
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    8 => notused0,  //= Reserved. Always write this bit as               1.
    9 => notused1,  //= Reserved. Always write this bit as               0.
    10 => notused2,  //= Reserved. Always write this bit as               1.
    11 => notused3,  //= Reserved. Always write this bit as               1.
    12 => notused4,  //= Reserved. Always write this bit as               0.
    13..15 => notused5,  //= Reserved. Always write these bits as               111.
  },
  0x238 => reg32 pdruncfg {  //! Power-down configuration           register
    0 => ircout_pd {  //! IRC oscillator output               power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    1 => irc_pd {  //! IRC oscillator power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    2 => flash_pd {  //! Flash power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    3 => bod_pd {  //! BOD power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    4 => adc_pd {  //! ADC power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    5 => sysosc_pd {  //! System oscillator               power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    6 => wdtosc_pd {  //! Watchdog oscillator               power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    7 => syspll_pd {  //! System PLL power-down
      0 => POWERED,  //= Powered
      1 => POWERED_DOWN,  //= Powered down
    }
    8 => notused0,  //= Reserved. Always write this bit as               1.
    9 => notused1,  //= Reserved. Always write this bit as               0.
    10 => notused2,  //= Reserved. Always write this bit as               1.
    11 => notused3,  //= Reserved. Always write this bit as               1.
    12 => notused4,  //= Reserved. Always write this bit as               0.
    13..15 => notused5,  //= Reserved. Always write these bits as               111.
  },
  0x3f4 => reg32 device_id {  //! Device ID register 0 for parts LPC1100,           LPC1100C, LPC1100L.
    0..31 => deviceid: ro,  //= Part ID numbers for LPC111x/LPC11Cxx               parts 0x041E 502B; 0x2516 D02B = LPC1111FHN33/101               0x2516 D02B = LPC1111FHN33/102 0x0416 502B; 0x2516               902B = LPC1111FHN33/201 0x2516 902B =               LPC1111FHN33/202 0x042D 502B; 0x2524 D02B =               LPC1112FHN33/101 0x2524 D02B = LPC1112FHN33/102               0x0425 502B; 0x2524 902B = LPC1112FHN33/201 0x2524               902B = LPC1112FHN33/202 0x2524 902B =               LPC1112FHI33/202 0x0434 502B; 0x2532 902B =               LPC1113FHN33/201 0x2532 902B = LPC1113FHN33/202               0x0434 102B; 0x2532 102B = LPC1113FHN33/301 0x2532               102B = LPC1113FHN33/302 0x0434 102B; 0x2532 102B =               LPC1113FBD48/301 0x2532 102B = LPC1113FBD48/302               0x0444 502B; 0x2540 902B = LPC1114FHN33/201 0x2540               902B = LPC1114FHN33/202 0x0444 102B; 0x2540 102B =               LPC1114FHN33/301 0x2540 102B = LPC1114FHN33/302               0x2540 102B = LPC1114FHI33/302 0x0444 102B; 0x2540               102B = LPC1114FBD48/301 0x2540 102B =               LPC1114FBD48/302 0x2540 102B = LPC11D14FBD100/302               0x1421 102B = LPC11C12/FBD48/301 0x1440 102B =               LPC11C14/FBD48/301 0x1431 102B = LPC11C22/FBD48/301               0X1430 102B = LPC11C24/FBD48/301
  },
});
ioregs! (C_CAN @ 0x40050000 = {  //! Product name title=UM10398 Chapter       title=LPC111x/LPC11Cxx C_CAN controller Modification       date=9/19/2011 Major revision=7 Minor revision=not       available
  0x00 => reg32 cancntl {  //! CAN control
    0 => init {  //! Initialization
      0 => NORMAL_OPERATION_,  //= Normal operation.
      1 => INITIALIZATION,  //= Initialization is started. On reset,                   software needs to initialize the CAN                   controller.
    }
    1 => ie {  //! Module interrupt enable
      0 => DISABLE_CAN_INTERRUP,  //= Disable CAN interrupts. The                   interrupt line is always HIGH.
      1 => ENABLE_CAN_INTERRUPT,  //= Enable CAN interrupts. The interrupt                   line is set to LOW and remains LOW until all                   pending interrupts are cleared.
    }
    2 => sie {  //! Status change interrupt               enable
      0 => DISABLE_STATUS_CHANG,  //= Disable status change interrupts. No                   status change interrupt will be                   generated.
      1 => ENABLE_STATUS_CHANGE,  //= Enable status change interrupts. A                   status change interrupt will be generated when a                   message transfer is successfully completed or a                   CAN bus error is detected.
    }
    3 => eie {  //! Error interrupt enable
      0 => DISABLE_ERROR_INTERR,  //= Disable error interrupt. No error                   status interrupt will be generated.
      1 => ENABLE_ERROR_INTERRU,  //= Enable error interrupt. A change in                   the bits BOFF or EWARN in the CANSTAT registers                   will generate an interrupt.
    }
    5 => dar {  //! Disable automatic               retransmission
      0 => ENABLED,  //= Automatic retransmission of                   disturbed messages enabled.
      1 => DISABLED,  //= Automatic retransmission                   disabled.
    }
    6 => cce {  //! Configuration change               enable
      0 => NOACCESS,  //= The CPU has no write access to the                   bit timing register.
      1 => ACCESS,  //= The CPU has write access to the                   CANBT register while the INIT bit is                   one.
    }
    7 => test {  //! Test mode enable
      0 => NORMAL_OPERATION_,  //= Normal operation.
      1 => TEST_MODE_,  //= Test mode.
    }
  },
  0x04 => reg32 canstat {  //! Status register
    0..2 => lec {  //! Last error code Type of the last error               to occur on the CAN bus.The LEC field holds a code               which indicates the type of the last error to occur               on the CAN bus. This field will be cleared to 0 when               a message has been transferred (reception or               transmission) without error. The unused code 111 may               be written by the CPU to check for               updates.
      0 => NO_ERROR_,  //= No error.
      1 => STUFF_ERROR,  //= Stuff error: More than 5 equal bits                   in a sequence have occurred in a part of a                   received message where this is not                   allowed.
      2 => FORM_ERROR,  //= Form error: A fixed format part of a                   received frame has the wrong                   format.
      3 => ACKERROR,  //= AckError: The message this CAN core                   transmitted was not acknowledged.
      4 => BIT1ERROR,  //= Bit1Error: During the transmission                   of a message (with the exception of the                   arbitration field), the device wanted to send a                   HIGH/recessive level (bit of logical value 1),                   but the monitored bus value was                   LOW/dominant.
      5 => BIT0ERROR,  //= Bit0Error: During the transmission                   of a message (or acknowledge bit, or active error                   flag, or overload flag), the device wanted to                   send a LOW/dominant level (data or identifier bit                   logical value 0), but the monitored Bus value was                   HIGH/recessive. During busoff recovery this                   status is set each time a sequence of 11                   HIGH/recessive bits has been monitored. This                   enables the CPU to monitor the proceeding of the                   busoff recovery sequence (indicating the bus is                   not stuck at LOW/dominant or continuously                   disturbed).
      6 => CRCERROR,  //= CRCError: The CRC checksum was                   incorrect in the message received.
      7 => UNUSED,  //= Unused: No CAN bus event was                   detected (written by the CPU).
    }
    3 => txok {  //! Transmitted a message successfully This               bit is reset by the CPU. It is never reset by the CAN               controller.
      0 => NOTRANSMIT,  //= Since this bit was reset by the CPU,                   no message has been successfully                   transmitted.
      1 => TRANSMIT,  //= Since this bit was last reset by the                   CPU, a message has been successfully transmitted                   (error free and acknowledged by at least one                   other node).
    }
    4 => rxok {  //! Received a message successfully This bit               is reset by the CPU. It is never reset by the CAN               controller.
      0 => NOTRANSMIT,  //= Since this bit was last reset by the                   CPU, no message has been successfully                   transmitted.
      1 => TRANSMIT,  //= Since this bit was last set to zero                   by the CPU, a message has been successfully                   received independent of the result of acceptance                   filtering.
    }
    5 => epass {  //! Error passive
      0 => ACTIVE,  //= The CAN controller is in the error                   active state.
      1 => PASSIVE,  //= The CAN controller is in the error                   passive state as defined in the CAN 2.0                   specification.
    }
    6 => ewarn {  //! Warning status
      0 => BELOWWARNINGLIM,  //= Both error counters are below the                   error warning limit of 96.
      1 => WARNINGLIM,  //= At least one of the error counters                   in the EML has reached the error warning limit of                   96.
    }
    7 => boff {  //! Busoff status
      0 => NOTBUSOFF,  //= The CAN module is not in                   busoff.
      1 => BUSOFF,  //= The CAN controller is in busoff                   state.
    }
  },
  0x08 => reg32 canec {  //! Error counter
    0..7 => tec_7_0: ro,  //= Transmit error counter Current value of               the transmit error counter (maximum value               255)
    8..14 => rec_6_0: ro,  //= Receive error counter Current value of               the receive error counter (maximum value               127).
    15 => rp: ro {  //! Receive error passive
      0 => BELOWERRORPASSIVE,  //= The receive counter is below the                   error passive level.
      1 => ERRORPASSIVE,  //= The receive counter has reached the                   error passive level as defined in the CAN2.0                   specification.
    }
  },
  0x0c => reg32 canbt {  //! Bit timing register
    0..5 => brp,  //= Baud rate prescaler The value by which               the oscillator frequency is divided for generating               the bit time quanta. The bit time is built up from a               multiple of this quanta. Valid values for the Baud               Rate Prescaler are 0 to 63.[1]
    6..7 => sjw,  //= (Re)synchronization jump width Valid               programmed values are 0 to 3.[1]
    8..11 => tseg1,  //= Time segment before the sample point               Valid values are 1 to 15.[1]
    12..14 => tseg2,  //= Time segment after the sample point               Valid values are 0 to 7.[1]
  },
  0x10 => reg32 canint {  //! Interrupt register
    0..15 => intid: ro,  //= 0x0000 = No interrupt is pending. 0x0001               - 0x0020 = Number of message object which caused the               interrupt. 0x0021 - 0x7FFF = Unused 0x8000 = Status               interrupt 0x8001 - 0xFFFF = Unused
  },
  0x14 => reg32 cantest {  //! Test register
    2 => basic {  //! Basic mode
      0 => BASIC_MODE_DISABLED_,  //= Basic mode disabled.
      1 => TXRX,  //= IF1 registers used as TX buffer, IF2                   registers used as RX buffer.
    }
    3 => silent {  //! Silent mode
      0 => NORMAL_OPERATION_,  //= Normal operation.
      1 => SILENT,  //= The module is in silent                   mode.
    }
    4 => lback {  //! Loop back mode
      0 => DISABLED,  //= Loop back mode is                   disabled.
      1 => ENABLED,  //= Loop back mode is                   enabled.
    }
    5..6 => tx {  //! Control of CAN_TXD pins
      0 => LEVEL,  //= Level at the CAN_TXD pin is                   controlled by the CAN controller. This is the                   value at reset.
      1 => TXD,  //= The sample point can be monitored at                   the CAN_TXD pin.
      2 => LOW,  //= CAN_TXD pin is driven                   LOW/dominant.
      3 => HIGH,  //= CAN_TXD pin is driven                   HIGH/recessive.
    }
    7 => rx {  //! Monitors the actual value of the CAN_RXD               pin.
      0 => RECESSIVE,  //= The CAN bus is recessive (CAN_RXD =                   1).
      1 => DORMANT,  //= The CAN bus is dominant (CAN_RXD =                   0).
    }
  },
  0x18 => reg32 canbrpe {  //! Baud rate prescaler extension           register
    0..3 => brpe,  //= Baud rate prescaler extension By               programming BRPE the Baud Rate Prescaler can be               extended to values up to 1023. Hardware interprets               the value as the value of BRPE (MSBs) and BRP (LSBs)               plus one. Allowed values are 0 to 15.
  },
  0x20 => reg32 canif1_cmdreq {  //! Message interface command           request
    0..5 => mn,  //= Message number 0x01 - 0x20 = Valid               message numbers. The message object in the message               RAM is selected for data transfer. 0x00 = Not a valid               message number. This value is interpreted as 0x20.[1]               0x21 - 0x3F = Not a valid message number. This value               is interpreted as 0x01 - 0x1F.[1]
    15 => busy {  //! BUSY flag
      0 => ZERO,  //= Set to zero by hardware when                   read/write action to this Command request                   register has finished.
      1 => ONE,  //= Set to one by hardware when writing                   to this Command request register.
    }
  },
  0x80 => reg32 canif2_cmdreq {  //! Message interface command           request
    0..5 => mn,  //= Message number 0x01 - 0x20 = Valid               message numbers. The message object in the message               RAM is selected for data transfer. 0x00 = Not a valid               message number. This value is interpreted as 0x20.[1]               0x21 - 0x3F = Not a valid message number. This value               is interpreted as 0x01 - 0x1F.[1]
    15 => busy {  //! BUSY flag
      0 => ZERO,  //= Set to zero by hardware when                   read/write action to this Command request                   register has finished.
      1 => ONE,  //= Set to one by hardware when writing                   to this Command request register.
    }
  },
  0x24 => reg32 canif1_cmdmsk_w {  //! Message interface command mask - write           direction
    0 => data_b {  //! Access data bytes 4-7
      0 => DATA_BYTES_4_7_UNCHA,  //= Data bytes 4-7                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 4-7 to message                   object.
    }
    1 => data_a {  //! Access data bytes 0-3
      0 => DATA_BYTES_0_3_UNCHA,  //= Data bytes 0-3                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 0-3 to message                   object.
    }
    2 => txrqst {  //! Access transmission request               bit
      0 => NO_TRANSMISSION_REQU,  //= No transmission request. TXRQSRT bit                   unchanged in IF1/2_MCTRL. If a transmission is                   requested by programming this bit, the TXRQST bit                   in the CANIFn_MCTRL register is                   ignored.
      1 => REQUEST_A_TRANSMISSI,  //= Request a transmission. Set the                   TXRQST bit IF1/2_MCTRL.
    }
    3 => clrintpnd,  //= This bit is ignored in the write               direction.
    4 => ctrl {  //! Access control bits
      0 => UNCHANGED,  //= Control bits                   unchanged.
      1 => TRANSFER_CONTROL_BIT,  //= Transfer control bits to message                   object
    }
    5 => arb {  //! Access arbitration bits
      0 => UNCHANGED,  //= Arbitration bits                   unchanged.
      1 => TRANSFER_IDENTIFIER,  //= Transfer Identifier, DIR, XTD, and                   MSGVAL bits to message object.
    }
    6 => mask {  //! Access mask bits
      0 => UNCHANGED,  //= Mask bits unchanged.
      1 => TRANSFER_IDENTIFIER_,  //= Transfer Identifier MASK + MDIR +                   MXTD to message object.
    }
    7 => wr_rd,  //= Write transfer Transfer data from the               selected message buffer registers to the message               object addressed by the command request register               CANIFn_CMDREQ.
  },
  0x84 => reg32 canif2_cmdmsk_w {  //! Message interface command mask - write           direction
    0 => data_b {  //! Access data bytes 4-7
      0 => DATA_BYTES_4_7_UNCHA,  //= Data bytes 4-7                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 4-7 to message                   object.
    }
    1 => data_a {  //! Access data bytes 0-3
      0 => DATA_BYTES_0_3_UNCHA,  //= Data bytes 0-3                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 0-3 to message                   object.
    }
    2 => txrqst {  //! Access transmission request               bit
      0 => NO_TRANSMISSION_REQU,  //= No transmission request. TXRQSRT bit                   unchanged in IF1/2_MCTRL. If a transmission is                   requested by programming this bit, the TXRQST bit                   in the CANIFn_MCTRL register is                   ignored.
      1 => REQUEST_A_TRANSMISSI,  //= Request a transmission. Set the                   TXRQST bit IF1/2_MCTRL.
    }
    3 => clrintpnd,  //= This bit is ignored in the write               direction.
    4 => ctrl {  //! Access control bits
      0 => UNCHANGED,  //= Control bits                   unchanged.
      1 => TRANSFER_CONTROL_BIT,  //= Transfer control bits to message                   object
    }
    5 => arb {  //! Access arbitration bits
      0 => UNCHANGED,  //= Arbitration bits                   unchanged.
      1 => TRANSFER_IDENTIFIER,  //= Transfer Identifier, DIR, XTD, and                   MSGVAL bits to message object.
    }
    6 => mask {  //! Access mask bits
      0 => UNCHANGED,  //= Mask bits unchanged.
      1 => TRANSFER_IDENTIFIER_,  //= Transfer Identifier MASK + MDIR +                   MXTD to message object.
    }
    7 => wr_rd,  //= Write transfer Transfer data from the               selected message buffer registers to the message               object addressed by the command request register               CANIFn_CMDREQ.
  },
  0x24 => reg32 canif1_cmdmsk_r {  //! Message interface command mask - read           direction
    0 => data_b {  //! Access data bytes 4-7
      0 => UNCHANGED,  //= Data bytes 4-7                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 4-7 to IFx                   message buffer register.
    }
    1 => data_a {  //! Access data bytes 0-3
      0 => UNCHANGED,  //= Data bytes 0-3                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 0-3 to IFx                   message buffer.
    }
    2 => newdat {  //! Access new data bit
      0 => UNCHANGED,  //= NEWDAT bit remains unchanged. A read                   access to a message object can be combined with                   the reset of the control bits INTPND and NEWDAT                   in IF1/2_MCTRL. The values of these bits                   transferred to the IFx Message Control Register                   always reflect the status before resetting these                   bits.
      1 => CLEAR_NEWDAT_BIT_IN_,  //= Clear NEWDAT bit in the message                   object.
    }
    3 => clrintpnd {  //! Clear interrupt pending               bit.
      0 => UNCHANGED,  //= INTPND bit remains                   unchanged.
      1 => CLEAR_INTPND_BIT_IN_,  //= Clear INTPND bit in the message                   object.
    }
    4 => ctrl {  //! Access control bits
      0 => UNCHANGED,  //= Control bits                   unchanged.
      1 => TRANSFER_CONTROL_BIT,  //= Transfer control bits to IFx message                   buffer.
    }
    5 => arb {  //! Access arbitration bits
      0 => UNCHANGED,  //= Arbitration bits                   unchanged.
      1 => TRANSFER_IDENTIFIER,  //= Transfer Identifier, DIR, XTD, and                   MSGVAL bits to IFx message buffer                   register.
    }
    6 => mask {  //! Access mask bits
      0 => UNCHANGED,  //= Mask bits unchanged.
      1 => TRANSFER_IDENTIFIER_,  //= Transfer Identifier MASK + MDIR +                   MXTD to IFx message buffer                   register.
    }
    7 => wr_rd,  //= Read transfer Transfer data from the               message object addressed by the command request               register to the selected message buffer registers               CANIFn_CMDREQ.
  },
  0x84 => reg32 canif2_cmdmsk_r {  //! Message interface command mask - read           direction
    0 => data_b {  //! Access data bytes 4-7
      0 => UNCHANGED,  //= Data bytes 4-7                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 4-7 to IFx                   message buffer register.
    }
    1 => data_a {  //! Access data bytes 0-3
      0 => UNCHANGED,  //= Data bytes 0-3                   unchanged.
      1 => TRANSFER_DATA_BYTES_,  //= Transfer data bytes 0-3 to IFx                   message buffer.
    }
    2 => newdat {  //! Access new data bit
      0 => UNCHANGED,  //= NEWDAT bit remains unchanged. A read                   access to a message object can be combined with                   the reset of the control bits INTPND and NEWDAT                   in IF1/2_MCTRL. The values of these bits                   transferred to the IFx Message Control Register                   always reflect the status before resetting these                   bits.
      1 => CLEAR_NEWDAT_BIT_IN_,  //= Clear NEWDAT bit in the message                   object.
    }
    3 => clrintpnd {  //! Clear interrupt pending               bit.
      0 => UNCHANGED,  //= INTPND bit remains                   unchanged.
      1 => CLEAR_INTPND_BIT_IN_,  //= Clear INTPND bit in the message                   object.
    }
    4 => ctrl {  //! Access control bits
      0 => UNCHANGED,  //= Control bits                   unchanged.
      1 => TRANSFER_CONTROL_BIT,  //= Transfer control bits to IFx message                   buffer.
    }
    5 => arb {  //! Access arbitration bits
      0 => UNCHANGED,  //= Arbitration bits                   unchanged.
      1 => TRANSFER_IDENTIFIER,  //= Transfer Identifier, DIR, XTD, and                   MSGVAL bits to IFx message buffer                   register.
    }
    6 => mask {  //! Access mask bits
      0 => UNCHANGED,  //= Mask bits unchanged.
      1 => TRANSFER_IDENTIFIER_,  //= Transfer Identifier MASK + MDIR +                   MXTD to IFx message buffer                   register.
    }
    7 => wr_rd,  //= Read transfer Transfer data from the               message object addressed by the command request               register to the selected message buffer registers               CANIFn_CMDREQ.
  },
  0x28 => reg32 canif1_msk1 {  //! Message interface 1 mask 1
    0..15 => msk_15_0 {  //! Identifier mask
      0 => NOINHIBIT,  //= The corresponding bit in the                   identifier of the message can not inhibit the                   match in the acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The corresponding identifier bit is                   used for acceptance filtering.
    }
  },
  0x88 => reg32 canif2_msk1 {  //! Message interface 1 mask 1
    0..15 => msk_15_0 {  //! Identifier mask
      0 => NOINHIBIT,  //= The corresponding bit in the                   identifier of the message can not inhibit the                   match in the acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The corresponding identifier bit is                   used for acceptance filtering.
    }
  },
  0x2c => reg32 canif1_msk2 {  //! Message interface 1 mask 2
    0..12 => msk_28_16 {  //! Identifier mask
      0 => NOINHIBIT,  //= The corresponding bit in the                   identifier of the message can not inhibit the                   match in the acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The corresponding identifier bit is                   used for acceptance filtering.
    }
    14 => mdir {  //! Mask message direction
      0 => NOEFFECT,  //= The message direction bit (DIR) has                   no effect on acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The message direction bit (DIR) is                   used for acceptance filtering.
    }
    15 => mxtd {  //! Mask extend identifier
      0 => NOEFFECT,  //= The extended identifier bit (XTD)                   has no effect on acceptance                   filtering.
      1 => ACCEPTANCEFILTERING,  //= The extended identifier bit (XTD) is                   used for acceptance filtering.
    }
  },
  0x8c => reg32 canif2_msk2 {  //! Message interface 1 mask 2
    0..12 => msk_28_16 {  //! Identifier mask
      0 => NOINHIBIT,  //= The corresponding bit in the                   identifier of the message can not inhibit the                   match in the acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The corresponding identifier bit is                   used for acceptance filtering.
    }
    14 => mdir {  //! Mask message direction
      0 => NOEFFECT,  //= The message direction bit (DIR) has                   no effect on acceptance filtering.
      1 => ACCEPTANCEFILTERING,  //= The message direction bit (DIR) is                   used for acceptance filtering.
    }
    15 => mxtd {  //! Mask extend identifier
      0 => NOEFFECT,  //= The extended identifier bit (XTD)                   has no effect on acceptance                   filtering.
      1 => ACCEPTANCEFILTERING,  //= The extended identifier bit (XTD) is                   used for acceptance filtering.
    }
  },
  0x30 => reg32 canif1_arb1 {  //! Message interface 1 arbitration           1
    0..15 => id_15_0,  //= Message identifier 29-bit identifier               (extended frame) 11-bit identifier (standard               frame)
  },
  0x90 => reg32 canif2_arb1 {  //! Message interface 1 arbitration           1
    0..15 => id_15_0,  //= Message identifier 29-bit identifier               (extended frame) 11-bit identifier (standard               frame)
  },
  0x34 => reg32 canif1_arb2 {  //! Message interface 1 arbitration           2
    0..12 => id_28_16,  //= Message identifier 29-bit identifier               (extended frame) 11-bit identifier (standard               frame)
    13 => dir {  //! Message direction
      0 => RECEIVE,  //= Direction = receive. On TXRQST, a                   Remote Frame with the identifier of this Message                   Object is transmitted. On reception of a Data                   Frame with matching identifier, that message is                   stored in this Message Object.
      1 => TRANSMIT,  //= Direction = transmit. On TXRQST, the                   respective Message Object is transmitted as a                   Data Frame. On reception of a Remote Frame with                   matching identifier, the TXRQST bit of this                   Message Object is set (if RMTEN =                   one).
    }
    14 => xtd {  //! Extend identifier
      0 => E_11_BIT_STANDARD_,  //= The 11-bit standard identifier will                   be used for this message object.
      1 => E_29_BIT_EXTENDED_,  //= The 29-bit extended identifier will                   be used for this message object.
    }
    15 => msgval {  //! Message valid The CPU must reset the               MSGVAL bit of all unused Messages Objects during the               initialization before it resets bit INIT in the CAN               Control Register. This bit must also be reset before               the identifier ID28:0, the control bits XTD, DIR, or               the Data Length Code DLC3:0 are modified, or if the               Messages Object is no longer required.
      0 => IGNORE,  //= The message object is ignored by the                   message handler.
      1 => CONFIGURED,  //= The message object is configured and                   should be considered by the message                   handler.
    }
  },
  0x94 => reg32 canif2_arb2 {  //! Message interface 1 arbitration           2
    0..12 => id_28_16,  //= Message identifier 29-bit identifier               (extended frame) 11-bit identifier (standard               frame)
    13 => dir {  //! Message direction
      0 => RECEIVE,  //= Direction = receive. On TXRQST, a                   Remote Frame with the identifier of this Message                   Object is transmitted. On reception of a Data                   Frame with matching identifier, that message is                   stored in this Message Object.
      1 => TRANSMIT,  //= Direction = transmit. On TXRQST, the                   respective Message Object is transmitted as a                   Data Frame. On reception of a Remote Frame with                   matching identifier, the TXRQST bit of this                   Message Object is set (if RMTEN =                   one).
    }
    14 => xtd {  //! Extend identifier
      0 => E_11_BIT_STANDARD_,  //= The 11-bit standard identifier will                   be used for this message object.
      1 => E_29_BIT_EXTENDED_,  //= The 29-bit extended identifier will                   be used for this message object.
    }
    15 => msgval {  //! Message valid The CPU must reset the               MSGVAL bit of all unused Messages Objects during the               initialization before it resets bit INIT in the CAN               Control Register. This bit must also be reset before               the identifier ID28:0, the control bits XTD, DIR, or               the Data Length Code DLC3:0 are modified, or if the               Messages Object is no longer required.
      0 => IGNORE,  //= The message object is ignored by the                   message handler.
      1 => CONFIGURED,  //= The message object is configured and                   should be considered by the message                   handler.
    }
  },
  0x38 => reg32 canif1_mctrl {  //! Message interface 1 message           control
    0..3 => dlc_3_0,  //= Data length code The Data Length Code of               a Message Object must be defined the same as in all               the corresponding objects with the same identifier at               other nodes. When the Message Handler stores a data               frame, it will write the DLC to the value given by               the received message. 0000 - 1000 = Data frame has 0               - 8 data bytes. 1001 - 1111 = Data frame has 8 data               bytes.
    7 => eob {  //! End of buffer
      0 => FIFO,  //= Message object belongs to a FIFO                   buffer and is not the last message object of that                   FIFO buffer.
      1 => SINGELAST,  //= Single message object or last                   message object of a FIFO buffer.
    }
    8 => txrqst {  //! Transmit request
      0 => NOWAIT,  //= This message object is not waiting                   for transmission.
      1 => WAIT,  //= The transmission of this message                   object is requested and is not yet                   done
    }
    9 => rmten {  //! Remote enable
      0 => NOCHANGE,  //= At the reception of a remote frame,                   TXRQST is left unchanged.
      1 => SET,  //= At the reception of a remote frame,                   TXRQST is set.
    }
    10 => rxie {  //! Receive interrupt enable
      0 => NOCHANGE,  //= INTPND will be left unchanged after                   successful reception of a frame.
      1 => SET,  //= INTPND will be set after successful                   reception of a frame.
    }
    11 => txie {  //! Transmit interrupt enable
      0 => NOCHANGE,  //= The INTPND bit will be left                   unchanged after a successful transmission of a                   frame.
      1 => SET,  //= INTPND will be set after a                   successful transmission of a frame.
    }
    12 => umask {  //! Use acceptance mask If UMASK is set to               1, the message object's mask bits have to be               programmed during initialization of the message               object before MAGVAL is set to 1.
      0 => IGNORE,  //= Mask ignored.
      1 => USEMASK,  //= Use mask (MSK[28:0], MXTD, and MDIR)                   for acceptance filtering.
    }
    13 => intpnd {  //! Interrupt pending
      0 => NOINTSOURCE,  //= This message object is not the                   source of an interrupt.
      1 => INTSOURCE,  //= This message object is the source of                   an interrupt. The Interrupt Identifier in the                   Interrupt Register will point to this message                   object if there is no other interrupt source with                   higher priority.
    }
    14 => msglst {  //! Message lost (only valid for message               objects in the direction receive).
      0 => NOLOST,  //= No message lost since this bit was                   reset last by the CPU.
      1 => NEWMESSAGE,  //= The Message Handler stored a new                   message into this object when NEWDAT was still                   set, the CPU has lost a message.
    }
    15 => newdat {  //! New data
      0 => NONEWDATA,  //= No new data has been written into                   the data portion of this message object by the                   message handler since this flag was cleared last                   by the CPU.
      1 => NEWDATA,  //= The message handler or the CPU has                   written new data into the data portion of this                   message object.
    }
  },
  0x98 => reg32 canif2_mctrl {  //! Message interface 1 message           control
    0..3 => dlc_3_0,  //= Data length code The Data Length Code of               a Message Object must be defined the same as in all               the corresponding objects with the same identifier at               other nodes. When the Message Handler stores a data               frame, it will write the DLC to the value given by               the received message. 0000 - 1000 = Data frame has 0               - 8 data bytes. 1001 - 1111 = Data frame has 8 data               bytes.
    7 => eob {  //! End of buffer
      0 => FIFO,  //= Message object belongs to a FIFO                   buffer and is not the last message object of that                   FIFO buffer.
      1 => SINGELAST,  //= Single message object or last                   message object of a FIFO buffer.
    }
    8 => txrqst {  //! Transmit request
      0 => NOWAIT,  //= This message object is not waiting                   for transmission.
      1 => WAIT,  //= The transmission of this message                   object is requested and is not yet                   done
    }
    9 => rmten {  //! Remote enable
      0 => NOCHANGE,  //= At the reception of a remote frame,                   TXRQST is left unchanged.
      1 => SET,  //= At the reception of a remote frame,                   TXRQST is set.
    }
    10 => rxie {  //! Receive interrupt enable
      0 => NOCHANGE,  //= INTPND will be left unchanged after                   successful reception of a frame.
      1 => SET,  //= INTPND will be set after successful                   reception of a frame.
    }
    11 => txie {  //! Transmit interrupt enable
      0 => NOCHANGE,  //= The INTPND bit will be left                   unchanged after a successful transmission of a                   frame.
      1 => SET,  //= INTPND will be set after a                   successful transmission of a frame.
    }
    12 => umask {  //! Use acceptance mask If UMASK is set to               1, the message object's mask bits have to be               programmed during initialization of the message               object before MAGVAL is set to 1.
      0 => IGNORE,  //= Mask ignored.
      1 => USEMASK,  //= Use mask (MSK[28:0], MXTD, and MDIR)                   for acceptance filtering.
    }
    13 => intpnd {  //! Interrupt pending
      0 => NOINTSOURCE,  //= This message object is not the                   source of an interrupt.
      1 => INTSOURCE,  //= This message object is the source of                   an interrupt. The Interrupt Identifier in the                   Interrupt Register will point to this message                   object if there is no other interrupt source with                   higher priority.
    }
    14 => msglst {  //! Message lost (only valid for message               objects in the direction receive).
      0 => NOLOST,  //= No message lost since this bit was                   reset last by the CPU.
      1 => NEWMESSAGE,  //= The Message Handler stored a new                   message into this object when NEWDAT was still                   set, the CPU has lost a message.
    }
    15 => newdat {  //! New data
      0 => NONEWDATA,  //= No new data has been written into                   the data portion of this message object by the                   message handler since this flag was cleared last                   by the CPU.
      1 => NEWDATA,  //= The message handler or the CPU has                   written new data into the data portion of this                   message object.
    }
  },
  0x3c => reg32 canif1_da1 {  //! Message interface 1 data A1
    0..7 => data0,  //= Data byte 0
    8..15 => data1,  //= Data byte 1
  },
  0x9c => reg32 canif2_da1 {  //! Message interface 1 data A1
    0..7 => data0,  //= Data byte 0
    8..15 => data1,  //= Data byte 1
  },
  0x40 => reg32 canif1_da2 {  //! Message interface 1 data A2
    0..7 => data2,  //= Data byte 2
    8..15 => data3,  //= Data byte 3
  },
  0xa0 => reg32 canif2_da2 {  //! Message interface 1 data A2
    0..7 => data2,  //= Data byte 2
    8..15 => data3,  //= Data byte 3
  },
  0x44 => reg32 canif1_db1 {  //! Message interface 1 data B1
    0..7 => data4,  //= Data byte 4
    8..15 => data5,  //= Data byte 5
  },
  0xa4 => reg32 canif2_db1 {  //! Message interface 1 data B1
    0..7 => data4,  //= Data byte 4
    8..15 => data5,  //= Data byte 5
  },
  0x48 => reg32 canif1_db2 {  //! Message interface 1 data B2
    0..7 => data6,  //= Data byte 6
    8..15 => data7,  //= Data byte 7
  },
  0xa8 => reg32 canif2_db2 {  //! Message interface 1 data B2
    0..7 => data6,  //= Data byte 6
    8..15 => data7,  //= Data byte 7
  },
  0x100 => reg32 cantxreq1 {  //! Transmission request 1
    0..15 => txrqst_16_1: ro,  //= Transmission request bit of message               objects 16 to 1. 0 = This message object is not               waiting for transmission. 1 = The transmission of               this message object is requested and not yet               done.
  },
  0x104 => reg32 cantxreq2 {  //! Transmission request 2
    0..15 => txrqst_32_17: ro,  //= Transmission request bit of message               objects 32 to 17. 0 = This message object is not               waiting for transmission. 1 = The transmission of               this message object is requested and not yet               done.
  },
  0x120 => reg32 cannd1 {  //! New data 1
    0..15 => newdat_16_1: ro,  //= New data bits of message objects 16 to               1. 0 = No new data has been written into the data               portion of this Message Object by the Message Handler               since last time this flag was cleared by the CPU. 1 =               The Message Handler or the CPU has written new data               into the data portion of this Message               Object.
  },
  0x124 => reg32 cannd2 {  //! New data 2
    0..15 => newdat_32_17: ro,  //= New data bits of message objects 32 to               17. 0 = No new data has been written into the data               portion of this Message Object by the Message Handler               since last time this flag was cleared by the CPU. 1 =               The Message Handler or the CPU has written new data               into the data portion of this Message               Object.
  },
  0x140 => reg32 canir1 {  //! Interrupt pending 1
    0..15 => intpnd_16_1: ro,  //= Interrupt pending bits of message               objects 16 to 1. 0 = This message object is ignored               by the message handler. 1 = This message object is               the source of an interrupt.
  },
  0x144 => reg32 canir2 {  //! Interrupt pending 2
    0..15 => intpnd_32_17: ro,  //= Interrupt pending bits of message               objects 32 to 17. 0 = This message object is ignored               by the message handler. 1 = This message object is               the source of an interrupt.
  },
  0x160 => reg32 canmsgv1 {  //! Message valid 1
    0..15 => msgval_16_1: ro,  //= Message valid bits of message objects 16               to 1. 0 = This message object is ignored by the               message handler. 1 = This message object is               configured and should be considered by the message               handler.
  },
  0x164 => reg32 canmsgv2 {  //! Message valid 2
    0..15 => msgval_32_17: ro,  //= Message valid bits of message objects 32               to 17. 0 = This message object is ignored by the               message handler. 1 = This message object is               configured and should be considered by the message               handler.
  },
  0x180 => reg32 canclkdiv {  //! Can clock divider register
    0..3 => clkdivval,  //= Clock divider value. CAN_CLK =               PCLK/(CLKDIVVAL +1) 0000: CAN_CLK = PCLK divided by               1. 0001: CAN_CLK = PCLK divided by 2. 0010: CAN_CLK =               PCLK divided by 3 0010: CAN_CLK = PCLK divided by 4.               ... 1111: CAN_CLK = PCLK divided by 16.
  },
});
ioregs! (SPI1 @ 0x40058000 = {  //! SPI0
  0x00 => reg32 cr0 {  //! Control Register 0. Selects the serial clock           rate, bus type, and data size.
    0..3 => dss {  //! Data Size Select. This field controls               the number of bits transferred in each frame. Values               0000-0010 are not supported and should not be               used.
      3 => E_4_BIT_TRANSFER,  //= 4-bit transfer
      4 => E_5_BIT_TRANSFER,  //= 5-bit transfer
      5 => E_6_BIT_TRANSFER,  //= 6-bit transfer
      6 => E_7_BIT_TRANSFER,  //= 7-bit transfer
      7 => E_8_BIT_TRANSFER,  //= 8-bit transfer
      8 => E_9_BIT_TRANSFER,  //= 9-bit transfer
      9 => E_10_BIT_TRANSFER,  //= 10-bit transfer
      10 => E_11_BIT_TRANSFER,  //= 11-bit transfer
      11 => E_12_BIT_TRANSFER,  //= 12-bit transfer
      12 => E_13_BIT_TRANSFER,  //= 13-bit transfer
      13 => E_14_BIT_TRANSFER,  //= 14-bit transfer
      14 => E_15_BIT_TRANSFER,  //= 15-bit transfer
      15 => E_16_BIT_TRANSFER,  //= 16-bit transfer
    }
    4..5 => frf {  //! Frame Format.
      0 => SPI,  //= SPI
      1 => TI,  //= TI
      2 => MICROWIRE,  //= Microwire
    }
    6 => cpol {  //! Clock Out Polarity. This bit is only               used in SPI mode.
      0 => LOW,  //= SPI controller maintains the bus                   clock low between frames.
      1 => HIGH,  //= SPI controller maintains the bus                   clock high between frames.
    }
    7 => cpha {  //! Clock Out Phase. This bit is only used               in SPI mode.
      0 => FIRSTCLOCK,  //= SPI controller captures serial data                   on the first clock transition of the frame, that                   is, the transition away from the inter-frame                   state of the clock line.
      1 => SECONDCLOCK,  //= SPI controller captures serial data                   on the second clock transition of the frame, that                   is, the transition back to the inter-frame state                   of the clock line.
    }
    8..15 => scr,  //= Serial Clock Rate. The number of               prescaler output clocks per bit on the bus, minus               one. Given that CPSDVSR is the prescale divider, and               the APB clock PCLK clocks the prescaler, the bit               frequency is PCLK / (CPSDVSR X               [SCR+1]).
  },
  0x04 => reg32 cr1 {  //! Control Register 1. Selects master/slave and           other modes.
    0 => lbm {  //! Loop Back Mode.
      0 => NORMAL,  //= During normal                   operation.
      1 => LOOPBACK,  //= Serial input is taken from the                   serial output (MOSI or MISO) rather than the                   serial input pin (MISO or MOSI                   respectively).
    }
    1 => sse {  //! SPI Enable.
      0 => DISABLE,  //= The SPI controller is                   disabled.
      1 => ENABLE,  //= The SPI controller will interact                   with other devices on the serial bus. Software                   should write the appropriate control information                   to the other SPI/SSP registers and interrupt                   controller registers, before setting this                   bit.
    }
    2 => ms {  //! Master/Slave Mode.This bit can only be               written when the SSE bit is 0.
      0 => MASTER,  //= The SPI controller acts as a master                   on the bus, driving the SCLK, MOSI, and SSEL                   lines and receiving the MISO line.
      1 => SLAVE,  //= The SPI controller acts as a slave                   on the bus, driving MISO line and receiving SCLK,                   MOSI, and SSEL lines.
    }
    3 => sod,  //= Slave Output Disable. This bit is               relevant only in slave mode (MS = 1). If it is 1,               this blocks this SPI controller from driving the               transmit data line (MISO).
  },
  0x08 => reg32 dr {  //! Data Register. Writes fill the transmit           FIFO, and reads empty the receive FIFO.
    0..15 => data,  //= Write: software can write data to be               sent in a future frame to this register whenever the               TNF bit in the Status register is 1, indicating that               the Tx FIFO is not full. If the Tx FIFO was               previously empty and the SPI controller is not busy               on the bus, transmission of the data will begin               immediately. Otherwise the data written to this               register will be sent as soon as all previous data               has been sent (and received). If the data length is               less than 16 bit, software must right-justify the               data written to this register. Read: software can               read data from this register whenever the RNE bit in               the Status register is 1, indicating that the Rx FIFO               is not empty. When software reads this register, the               SPI controller returns data from the least recent               frame in the Rx FIFO. If the data length is less than               16 bit, the data is right-justified in this field               with higher order bits filled with 0s.
  },
  0x0c => reg32 sr {  //! Status Register
    0 => tfe: ro,  //= Transmit FIFO Empty. This bit is 1 is               the Transmit FIFO is empty, 0 if not.
    1 => tnf: ro,  //= Transmit FIFO Not Full. This bit is 0 if               the Tx FIFO is full, 1 if not.
    2 => rne: ro,  //= Receive FIFO Not Empty. This bit is 0 if               the Receive FIFO is empty, 1 if not.
    3 => rff: ro,  //= Receive FIFO Full. This bit is 1 if the               Receive FIFO is full, 0 if not.
    4 => bsy: ro,  //= Busy. This bit is 0 if the SPI               controller is idle, 1 if it is currently               sending/receiving a frame and/or the Tx FIFO is not               empty.
  },
  0x10 => reg32 cpsr {  //! Clock Prescale Register
    0..7 => cpsdvsr,  //= This even value between 2 and 254, by               which SPI_PCLK is divided to yield the prescaler               output clock. Bit 0 always reads as 0.
  },
  0x14 => reg32 imsc {  //! Interrupt Mask Set and Clear           Register
    0 => rorim,  //= Software should set this bit to enable               interrupt when a Receive Overrun occurs, that is,               when the Rx FIFO is full and another frame is               completely received. The ARM spec implies that the               preceding frame data is overwritten by the new frame               data when this occurs.
    1 => rtim,  //= Software should set this bit to enable               interrupt when a Receive Time-out condition occurs. A               Receive Time-out occurs when the Rx FIFO is not               empty, and no has not been read for a time-out               period. The time-out period is the same for master               and slave modes and is determined by the SSP bit               rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
    2 => rxim,  //= Software should set this bit to enable               interrupt when the Rx FIFO is at least half               full.
    3 => txim,  //= Software should set this bit to enable               interrupt when the Tx FIFO is at least half               empty.
  },
  0x18 => reg32 ris {  //! Raw Interrupt Status Register
    0 => rorris: ro,  //= This bit is 1 if another frame was               completely received while the RxFIFO was full. The               ARM spec implies that the preceding frame data is               overwritten by the new frame data when this               occurs.
    1 => rtris: ro,  //= This bit is 1 if the Rx FIFO is not               empty, and has not been read for a time-out period.               The time-out period is the same for master and slave               modes and is determined by the SSP bit rate: 32 bits               at PCLK / (CPSDVSR x [SCR+1]).
    2 => rxris: ro,  //= This bit is 1 if the Rx FIFO is at least               half full.
    3 => txris: ro,  //= This bit is 1 if the Tx FIFO is at least               half empty.
  },
  0x1c => reg32 mis {  //! Masked Interrupt Status           Register
    0 => rormis: ro,  //= This bit is 1 if another frame was               completely received while the RxFIFO was full, and               this interrupt is enabled.
    1 => rtmis: ro,  //= This bit is 1 if the Rx FIFO is not               empty, has not been read for a time-out period, and               this interrupt is enabled. The time-out period is the               same for master and slave modes and is determined by               the SSP bit rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
    2 => rxmis: ro,  //= This bit is 1 if the Rx FIFO is at least               half full, and this interrupt is               enabled.
    3 => txmis: ro,  //= This bit is 1 if the Tx FIFO is at least               half empty, and this interrupt is               enabled.
  },
  0x20 => reg32 icr {  //! SSPICR Interrupt Clear           Register
    0 => roric: wo,  //= Writing a 1 to this bit clears the frame               was received when RxFIFO was full               interrupt.
    1 => rtic: wo,  //= Writing a 1 to this bit clears the Rx               FIFO was not empty and has not been read for a               timeout period interrupt. The timeout period is the               same for master and slave modes and is determined by               the SSP bit rate: 32 bits at PCLK / (CPSDVSR x               [SCR+1]).
  },
});
ioregs! (GPIO0 @ 0x50000000 = {  //! GPIO0
  0x3ffc => reg32 data {  //! Port n data register for pins PIOn_0 to           PIOn_11
    0 => data0,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    1 => data1,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    2 => data2,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    3 => data3,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    4 => data4,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    5 => data5,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    6 => data6,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    7 => data7,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    8 => data8,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    9 => data9,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    10 => data10,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    11 => data11,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
  },
  0x8000 => reg32 dir {  //! Data direction register for port           n
    0 => io0,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    1 => io1,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    2 => io2,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    3 => io3,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    4 => io4,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    5 => io5,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    6 => io6,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    7 => io7,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    8 => io8,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    9 => io9,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    10 => io10,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    11 => io11,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
  },
  0x8004 => reg32 is {  //! Interrupt sense register for port           n
    0 => isense0,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    1 => isense1,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    2 => isense2,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    3 => isense3,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    4 => isense4,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    5 => isense5,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    6 => isense6,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    7 => isense7,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    8 => isense8,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    9 => isense9,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    10 => isense10,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    11 => isense11,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
  },
  0x8008 => reg32 ibe {  //! Interrupt both edges register for port           n
    0 => ibe0,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    1 => ibe1,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    2 => ibe2,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    3 => ibe3,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    4 => ibe4,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    5 => ibe5,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    6 => ibe6,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    7 => ibe7,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    8 => ibe8,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    9 => ibe9,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    10 => ibe10,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    11 => ibe11,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
  },
  0x800c => reg32 iev {  //! Interrupt event register for port           n
    0 => iev0,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    1 => iev1,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    2 => iev2,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    3 => iev3,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    4 => iev4,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    5 => iev5,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    6 => iev6,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    7 => iev7,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    8 => iev8,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    9 => iev9,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    10 => iev10,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    11 => iev11,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
  },
  0x8010 => reg32 ie {  //! Interrupt mask register for port           n
    0 => mask0,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    1 => mask1,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    2 => mask2,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    3 => mask3,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    4 => mask4,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    5 => mask5,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    6 => mask6,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    7 => mask7,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    8 => mask8,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    9 => mask9,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    10 => mask10,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    11 => mask11,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
  },
  0x8014 => reg32 ris {  //! Raw interrupt status register for port           n
    0 => rawst0: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    1 => rawst1: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    2 => rawst2: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    3 => rawst3: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    4 => rawst4: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    5 => rawst5: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    6 => rawst6: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    7 => rawst7: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    8 => rawst8: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    9 => rawst9: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    10 => rawst10: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    11 => rawst11: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
  },
  0x8018 => reg32 mis {  //! Masked interrupt status register for port           n
    0 => mask0: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    1 => mask1: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    2 => mask2: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    3 => mask3: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    4 => mask4: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    5 => mask5: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    6 => mask6: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    7 => mask7: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    8 => mask8: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    9 => mask9: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    10 => mask10: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    11 => mask11: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
  },
  0x801c => reg32 ic {  //! Interrupt clear register for port           n
    0 => clr0: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    1 => clr1: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    2 => clr2: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    3 => clr3: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    4 => clr4: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    5 => clr5: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    6 => clr6: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    7 => clr7: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    8 => clr8: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    9 => clr9: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    10 => clr10: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    11 => clr11: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
  },
});
ioregs! (GPIO1 @ 0x50010000 = {  //! GPIO0
  0x3ffc => reg32 data {  //! Port n data register for pins PIOn_0 to           PIOn_11
    0 => data0,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    1 => data1,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    2 => data2,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    3 => data3,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    4 => data4,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    5 => data5,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    6 => data6,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    7 => data7,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    8 => data8,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    9 => data9,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    10 => data10,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    11 => data11,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
  },
  0x8000 => reg32 dir {  //! Data direction register for port           n
    0 => io0,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    1 => io1,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    2 => io2,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    3 => io3,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    4 => io4,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    5 => io5,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    6 => io6,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    7 => io7,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    8 => io8,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    9 => io9,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    10 => io10,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    11 => io11,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
  },
  0x8004 => reg32 is {  //! Interrupt sense register for port           n
    0 => isense0,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    1 => isense1,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    2 => isense2,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    3 => isense3,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    4 => isense4,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    5 => isense5,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    6 => isense6,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    7 => isense7,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    8 => isense8,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    9 => isense9,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    10 => isense10,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    11 => isense11,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
  },
  0x8008 => reg32 ibe {  //! Interrupt both edges register for port           n
    0 => ibe0,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    1 => ibe1,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    2 => ibe2,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    3 => ibe3,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    4 => ibe4,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    5 => ibe5,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    6 => ibe6,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    7 => ibe7,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    8 => ibe8,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    9 => ibe9,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    10 => ibe10,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    11 => ibe11,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
  },
  0x800c => reg32 iev {  //! Interrupt event register for port           n
    0 => iev0,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    1 => iev1,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    2 => iev2,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    3 => iev3,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    4 => iev4,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    5 => iev5,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    6 => iev6,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    7 => iev7,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    8 => iev8,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    9 => iev9,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    10 => iev10,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    11 => iev11,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
  },
  0x8010 => reg32 ie {  //! Interrupt mask register for port           n
    0 => mask0,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    1 => mask1,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    2 => mask2,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    3 => mask3,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    4 => mask4,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    5 => mask5,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    6 => mask6,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    7 => mask7,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    8 => mask8,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    9 => mask9,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    10 => mask10,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    11 => mask11,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
  },
  0x8014 => reg32 ris {  //! Raw interrupt status register for port           n
    0 => rawst0: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    1 => rawst1: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    2 => rawst2: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    3 => rawst3: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    4 => rawst4: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    5 => rawst5: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    6 => rawst6: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    7 => rawst7: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    8 => rawst8: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    9 => rawst9: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    10 => rawst10: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    11 => rawst11: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
  },
  0x8018 => reg32 mis {  //! Masked interrupt status register for port           n
    0 => mask0: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    1 => mask1: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    2 => mask2: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    3 => mask3: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    4 => mask4: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    5 => mask5: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    6 => mask6: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    7 => mask7: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    8 => mask8: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    9 => mask9: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    10 => mask10: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    11 => mask11: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
  },
  0x801c => reg32 ic {  //! Interrupt clear register for port           n
    0 => clr0: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    1 => clr1: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    2 => clr2: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    3 => clr3: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    4 => clr4: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    5 => clr5: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    6 => clr6: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    7 => clr7: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    8 => clr8: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    9 => clr9: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    10 => clr10: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    11 => clr11: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
  },
});
ioregs! (GPIO2 @ 0x50020000 = {  //! GPIO0
  0x3ffc => reg32 data {  //! Port n data register for pins PIOn_0 to           PIOn_11
    0 => data0,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    1 => data1,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    2 => data2,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    3 => data3,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    4 => data4,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    5 => data5,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    6 => data6,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    7 => data7,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    8 => data8,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    9 => data9,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    10 => data10,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    11 => data11,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
  },
  0x8000 => reg32 dir {  //! Data direction register for port           n
    0 => io0,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    1 => io1,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    2 => io2,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    3 => io3,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    4 => io4,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    5 => io5,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    6 => io6,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    7 => io7,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    8 => io8,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    9 => io9,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    10 => io10,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    11 => io11,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
  },
  0x8004 => reg32 is {  //! Interrupt sense register for port           n
    0 => isense0,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    1 => isense1,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    2 => isense2,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    3 => isense3,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    4 => isense4,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    5 => isense5,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    6 => isense6,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    7 => isense7,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    8 => isense8,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    9 => isense9,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    10 => isense10,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    11 => isense11,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
  },
  0x8008 => reg32 ibe {  //! Interrupt both edges register for port           n
    0 => ibe0,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    1 => ibe1,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    2 => ibe2,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    3 => ibe3,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    4 => ibe4,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    5 => ibe5,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    6 => ibe6,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    7 => ibe7,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    8 => ibe8,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    9 => ibe9,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    10 => ibe10,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    11 => ibe11,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
  },
  0x800c => reg32 iev {  //! Interrupt event register for port           n
    0 => iev0,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    1 => iev1,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    2 => iev2,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    3 => iev3,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    4 => iev4,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    5 => iev5,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    6 => iev6,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    7 => iev7,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    8 => iev8,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    9 => iev9,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    10 => iev10,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    11 => iev11,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
  },
  0x8010 => reg32 ie {  //! Interrupt mask register for port           n
    0 => mask0,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    1 => mask1,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    2 => mask2,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    3 => mask3,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    4 => mask4,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    5 => mask5,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    6 => mask6,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    7 => mask7,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    8 => mask8,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    9 => mask9,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    10 => mask10,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    11 => mask11,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
  },
  0x8014 => reg32 ris {  //! Raw interrupt status register for port           n
    0 => rawst0: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    1 => rawst1: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    2 => rawst2: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    3 => rawst3: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    4 => rawst4: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    5 => rawst5: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    6 => rawst6: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    7 => rawst7: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    8 => rawst8: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    9 => rawst9: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    10 => rawst10: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    11 => rawst11: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
  },
  0x8018 => reg32 mis {  //! Masked interrupt status register for port           n
    0 => mask0: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    1 => mask1: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    2 => mask2: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    3 => mask3: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    4 => mask4: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    5 => mask5: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    6 => mask6: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    7 => mask7: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    8 => mask8: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    9 => mask9: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    10 => mask10: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    11 => mask11: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
  },
  0x801c => reg32 ic {  //! Interrupt clear register for port           n
    0 => clr0: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    1 => clr1: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    2 => clr2: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    3 => clr3: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    4 => clr4: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    5 => clr5: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    6 => clr6: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    7 => clr7: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    8 => clr8: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    9 => clr9: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    10 => clr10: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    11 => clr11: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
  },
});
ioregs! (GPIO3 @ 0x50030000 = {  //! GPIO0
  0x3ffc => reg32 data {  //! Port n data register for pins PIOn_0 to           PIOn_11
    0 => data0,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    1 => data1,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    2 => data2,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    3 => data3,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    4 => data4,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    5 => data5,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    6 => data6,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    7 => data7,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    8 => data8,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    9 => data9,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    10 => data10,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
    11 => data11,  //= Logic levels for pins PIOn_0 to PIOn_11.               HIGH = 1, LOW = 0.
  },
  0x8000 => reg32 dir {  //! Data direction register for port           n
    0 => io0,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    1 => io1,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    2 => io2,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    3 => io3,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    4 => io4,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    5 => io5,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    6 => io6,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    7 => io7,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    8 => io8,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    9 => io9,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    10 => io10,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
    11 => io11,  //= Selects pin x as input or output (x = 0               to 11). 0 = Pin PIOn_x is configured as input. 1 =               Pin PIOn_x is configured as output.
  },
  0x8004 => reg32 is {  //! Interrupt sense register for port           n
    0 => isense0,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    1 => isense1,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    2 => isense2,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    3 => isense3,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    4 => isense4,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    5 => isense5,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    6 => isense6,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    7 => isense7,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    8 => isense8,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    9 => isense9,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    10 => isense10,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
    11 => isense11,  //= Selects interrupt on pin x as level or               edge sensitive (x = 0 to 11). 0 = Interrupt on pin               PIOn_x is configured as edge sensitive. 1 = Interrupt               on pin PIOn_x is configured as level               sensitive.
  },
  0x8008 => reg32 ibe {  //! Interrupt both edges register for port           n
    0 => ibe0,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    1 => ibe1,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    2 => ibe2,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    3 => ibe3,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    4 => ibe4,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    5 => ibe5,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    6 => ibe6,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    7 => ibe7,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    8 => ibe8,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    9 => ibe9,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    10 => ibe10,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
    11 => ibe11,  //= Selects interrupt on pin x to be               triggered on both edges (x = 0 to 11). 0 = Interrupt               on pin PIOn_x is controlled through register               GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an               interrupt.
  },
  0x800c => reg32 iev {  //! Interrupt event register for port           n
    0 => iev0,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    1 => iev1,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    2 => iev2,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    3 => iev3,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    4 => iev4,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    5 => iev5,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    6 => iev6,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    7 => iev7,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    8 => iev8,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    9 => iev9,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    10 => iev10,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
    11 => iev11,  //= Selects interrupt on pin x to be               triggered rising or falling edges (x = 0 to 11). 0 =               Depending on setting in register GPIOnIS (see Table               109), falling edges or LOW level on pin PIOn_x               trigger an interrupt. 1 = Depending on setting in               register GPIOnIS (see Table 109), rising edges or               HIGH level on pin PIOn_x trigger an               interrupt.
  },
  0x8010 => reg32 ie {  //! Interrupt mask register for port           n
    0 => mask0,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    1 => mask1,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    2 => mask2,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    3 => mask3,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    4 => mask4,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    5 => mask5,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    6 => mask6,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    7 => mask7,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    8 => mask8,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    9 => mask9,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    10 => mask10,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
    11 => mask11,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked.               1 = Interrupt on pin PIOn_x is not               masked.
  },
  0x8014 => reg32 ris {  //! Raw interrupt status register for port           n
    0 => rawst0: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    1 => rawst1: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    2 => rawst2: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    3 => rawst3: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    4 => rawst4: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    5 => rawst5: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    6 => rawst6: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    7 => rawst7: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    8 => rawst8: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    9 => rawst9: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    10 => rawst10: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
    11 => rawst11: ro,  //= Raw interrupt status (x = 0 to 11). 0 =               No interrupt on pin PIOn_x. 1 = Interrupt               requirements met on PIOn_x.
  },
  0x8018 => reg32 mis {  //! Masked interrupt status register for port           n
    0 => mask0: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    1 => mask1: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    2 => mask2: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    3 => mask3: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    4 => mask4: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    5 => mask5: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    6 => mask6: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    7 => mask7: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    8 => mask8: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    9 => mask9: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    10 => mask10: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
    11 => mask11: ro,  //= Selects interrupt on pin x to be masked               (x = 0 to 11). 0 = No interrupt or interrupt masked               on pin PIOn_x. 1 = Interrupt on PIOn_x.
  },
  0x801c => reg32 ic {  //! Interrupt clear register for port           n
    0 => clr0: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    1 => clr1: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    2 => clr2: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    3 => clr3: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    4 => clr4: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    5 => clr5: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    6 => clr6: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    7 => clr7: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    8 => clr8: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    9 => clr9: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    10 => clr10: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
    11 => clr11: wo,  //= Selects interrupt on pin x to be cleared               (x = 0 to 11). Clears the interrupt edge detection               logic. This register is write-only. The synchronizer               between the GPIO and the NVIC blocks causes a delay               of 2 clocks. It is recommended to add two NOPs after               the clear of the interrupt edge detection logic               before the exit of the interrupt service routine. 0 =               No effect. 1 = Clears edge detection logic for pin               PIOn_x.
  },
});
